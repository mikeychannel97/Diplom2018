/***************************************************************************

                                XKY_HBO_4_1.c
                             -------------------
 
 ***************************************************************************/

#include "stdafx.h"
extern double MKC[];
extern double TKOC[];

 
/* 03.10.2006 */
static int    kik;

/*--------------------------------------------------------
|                       RIPM                             |
|          Пересчет вектора R в вектор P                 |
|                                                        |
|   Вход : r[6]                                          |
|                                                        |
|   Выход: p[6]                                          |
|                                                        |
|   Используются константы :                             |
|            FM     = 398600.44          TKOC[3]         |
|                                                        |
|                                          04.10.2004    |
|-------------------------------------------------------*/
int RIPM(double r[6],double p[6])
{
	 double a,b,c;

	 c = r[1] * cos(r[2]);
	 b = r[0] * c;
	 p[0] = b * b / TKOC[3];
	 a = b * c / TKOC[3] - 1.0;
	 b*= r[1] * sin(r[2]) / TKOC[3];
	 p[1] = a * sin(r[5]) - b * cos(r[5]);
	 p[2] = a * cos(r[5]) + b * sin(r[5]);
 	 p[3] = r[3];
	 p[4] = r[4];
	 p[5] = r[5];

	 return 0;
}
/******************************* end RIPM ************************************************/

/*--------------------------------------------------------
|                       PIRM                             |
|          Пересчет вектора P в вектор R                 |
|                                                        |
|   Вход : p[6]                                          |
|                                                        |
|   Выход: r[6]                                          |
|                                                        |
|   Используются константы :                             |
|            FM     = 398600.44          TKOC[3]         |
|                                                        |  
|                                          04.10.2004    |
|-------------------------------------------------------*/
int PIRM(double p[6],double r[6])
{
	 double su,cu,rw;

	 su = sin(p[5]);
	 cu = cos(p[5]);
	 rw = 1.0 + p[2] * cu + p[1] * su;
	 r[0] = p[0] / rw;
	 r[1] = sqrt ( TKOC[3] * ( 2.0 * rw + p[1] * p[1] + p[2] * p[2] - 1.0 ) / p[0]);
	 r[2] = atan (( p[2] * su - p[1] * cu ) / rw);
	 r[3] = p[3];
	 r[4] = p[4];
	 r[5] = p[5];

	 return 0;
}
/*********************************** end PIRM ********************************************/

/*-------------------------------------------------------
|                         PERUGM                         |
|            П е p е с ч е т   у г л о в                 |
|                                                        |
|                 осуществляется :                       |
|   из экватоpиальной СК в меpидианальную СК   пpи pr=1  |
|   из меpидианaльной СК в экватоpиальную СК   пpи pr=0  |
|                                                        | 
|   Вход : bx [3],pr                                     |
|                                                        |
|   Выход: bx1[3]                                        |
|                                                        |
|   Используемые константы :                             |
|               KP     = 1.0e-14             TKOC[20]    |
|               DVAPI  = 6.283185307179586   TKOC[11]    |
|                                                        |
|   Используемая процедура :  UGOLM()                    |
|                                          10.11.2004    |
|-------------------------------------------------------*/
int PERUGM(double bx[3],int pr,double bx1[3])
{
	 double cu,com,ci,su,som,si,rx,ry,rz,nx,ny,nz;
	 double i,omega,u,i1,omeg1,u1;
   
	 i     = bx[0];
	 omega = bx[1];
	 u     = bx[2];
	 su    = sin(u);
	 cu    = cos(u);
	 som   = sin(omega);
	 com   = cos(omega);
	 si    = sin(i);
	 ci    = cos(i);

     if(pr==1)
	 {
       if((i-TKOC[20])<0.0&&(omega-TKOC[20])<0.0)
	   {
			i1 = TKOC[11]/4.0; omeg1 = TKOC[11]/4.0; u1 = u; goto M;
	   }
	   nx  = ci;
 	   ny  = si*som;
	   nz  =-si*com;
	   rx  = su*si;
	   ry  = cu*com-su*som*ci;
	   rz  = cu*som+su*com*ci;
	 }
     else
	 {
       if((fabs(i-TKOC[11]/4.0)-TKOC[20])<0.0&&(fabs(omega-TKOC[11]/4.0)-TKOC[20])<0.0)
	   {
		  i1 = 0.0; omeg1 = 0.0; u1 = u; goto M;
	   }
	   nx    =-si*com;
	   ny    = ci;
	   nz    = si*som;
	   rx    = cu*som+su*com*ci;
	   ry    = su*si;
	   rz    = cu*com-su*som*ci;
	 }
	 i1  = acos(nz);
     si  = sin(i1);
	 som = nx/si; com = -ny/si; 
     UGOLM(som,com,&omeg1);
	 su  = rz/si;
	 cu  = rx*cos(omeg1)+ry*sin(omeg1);
     UGOLM(su,cu,&u1); 
  M: bx1[0]=i1;
     bx1[1]=omeg1;
     bx1[2]=u1;
	 return 0;
}
/************************************ end PERUGM ****************************************/
	
/*---------------------------------------------------------------------
|                                 PEING                               |
|             Пересчёт координат КА    из инерциальной  с.к. Xin[]    |
|                 в вектор Xpz[], заданный в прямоугольной с.к. ПЗ-90 |
|                                                                     |
|     Вход : Xin [X,Y,Z,X_t,Y_t,Z_t]                                  |
|                         - координаты положения КА                   |
|                           в инерциальной  с.к.                      |
|            MJD          - модифицированная юлианская дата           |
|                           зпохи измерений                           |
|            DEL_UT1      - поправка в значение UTC                   |
|                                                                     |
|     Выход: Xpz [X,Y,Z,X_t,Y_t,Z_t]                                  |
|                         - координаты положения КА                   |
|                           в  с.к. ПЗ-90                             |
|                                                                     |
|     Используются процедуры : MNUT, ZVEWI,                           |
|                              YM_MV_6                                |
|     Используются константы :                                        |
|                  PI     = 3.14159265358979         TKOC[1]          |
|                  OMEGAZ = 0.729211585530659e-4     TKOC[2]          |
|                  Xp_MUN - координаты мгновенного полюса  TKOC[61]   |
|                  Yp_MUN   относителбно МУН               TKOC[62]   |
|                                                                     |
|                                                         14.10.2005  |
|--------------------------------------------------------------------*/
int  PEING (double Xin[6], double MJD, double DEL_UT1, double Xpz[6])
{
	 double Xek[6],Xg[6];
 	 double P[3][3];
	 double Nt[3][3];

	 double A66[6][6];
     int j, l;
	 double N_alfa, Xp_r, Yp_r, s, s_s, c_s, Xp_MUN, Yp_MUN;

	 Xp_MUN = TKOC[61];
     Yp_MUN = TKOC[62];

     MNUT(MJD, Nt);
     for (l=0; l<6; l++)
	 {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	 }
     for (l=0; l<3; l++)
	 {   
	      for (j=0; j<3; j++)
		  {
		   A66[l][j] = Nt[l][j];
		   A66[l+3][j+3] = Nt[l][j];
		  }	 
	 }
     YM_MV_6 (A66, Xin, Xek);
     N_alfa = Nt[1][0];
	 ZVEWI( MJD, DEL_UT1, N_alfa, &s);
     for (l=0; l<6; l++)
	 {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	 }
     A66[2][2] = 1.0;
	 A66[5][5] = 1.0;
	 s_s = sin(s);
	 c_s = cos(s);
     A66[0][0] =   c_s;	 A66[0][1] = s_s;
     A66[1][0] = - s_s;	 A66[1][1] = c_s;
     A66[3][0] = - TKOC[2] * s_s;	  A66[3][1] =   TKOC[2] * c_s;
	 A66[3][3] =   c_s;               A66[3][4] =   s_s;
     A66[4][0] = - TKOC[2] * c_s;	  A66[4][1] = - TKOC[2] * s_s;
	 A66[4][3] = - s_s;               A66[4][4] =   c_s;
     YM_MV_6 (A66, Xek, Xg);    
     Xp_r = Xp_MUN * TKOC[1] / 64800;
	 Yp_r = Yp_MUN * TKOC[1] / 64800;
     P[0][0] = 1.0;
     P[1][1] = 1.0;
     P[2][2] = 1.0;
     P[0][1] = 0.0;
     P[1][0] = 0.0;
     P[0][2] =  Xp_r;
     P[2][0] = -Xp_r;
     P[1][2] = -Yp_r;
     P[2][1] =  Yp_r;
     for (l=0; l<6; l++)
	 {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	 }
     for (l=0; l<3; l++)
	 {   
	      for (j=0; j<3; j++)
		  {
		   A66[l][j] = P[l][j];
		   A66[l+3][j+3] = P[l][j];
		  }	 
	 }
     YM_MV_6 (A66, Xg, Xpz);

	 return 0;
}
/************************************* end PEING ******************************************/

/*--------------------------------------------------------------------------
|                                 STISF                                    |
|                        Пересчёт координат КА                             |
| из прямоугольной горизонтальной астрономической с.к. X[X,Y,Z,X_t,Y_t,Z_t]|
| в сферическую  с.к. (D,D_t,alfa,beta)                                    |
|                                                                          |
|     Вход : X[]                                                           |
|            X[0],X[1],X[2]  - координаты положения КА                     |
|                              в прямоугольной с.к.                        |
|            X[3],X[4],X[5]  - координаты вектора скорости КА              |
|                              в прямоугольной станционной с.к.            |
|     Выход: D,D_t,alfa,beta                                               |
|            D     - дальность до КА                                       |
|            D_t   - радиальная скорость КА в направлении станции          |                            |
|            alfa  - азимут КА                                             |
|            beta  - угол места КА                                         |
|                                                                          |
|     Используются константы :                                             |
|                     PI     = 3.14159265358979   TKOC[1]                  |
|                     DVAPI  = 6.28318530717959   TKOC[11]                 |
|                                                                          |
|                                            12.07.2004                    |
|-------------------------------------------------------------------------*/
int  STISF (double X[6],double *D, double *D_t, double *alfa, double *beta)
{	
	double a, alfa_2pi ;

    *D = sqrt(X[0] * X[0] + X[1] * X[1] + X[2] * X[2]);
	*D_t = (X[0] * X[3] + X[1] * X[4] + X[2] * X[5]) / *D;

    a = sqrt ( X[1] * X[1] + X[2] * X[2]);

    if (a == 0.) *alfa = 0.;
	else
		{ 
		alfa_2pi = asin (- X[1] / a);
		if (X[2] < 0.)  *alfa = TKOC[1] - alfa_2pi;

		else
			{
			if (X[1] < 0.)  *alfa = alfa_2pi;
			
			if (X[1] >= 0.) *alfa = TKOC[11] + alfa_2pi;
		    }

	    }
    *beta = asin ( X[0] / (*D) );

	return 0;
}
/******************************* end STISF ***********************************************/

/*--------------------------------------------------------------------
|                               POSTM                                |
|               Пересчёт вектора орбитальных параметров P()          |
|                в прямоугольную  с.к. X [X,Y.Z,X_t,Y_t,Z_t]         |
|                                                                    |
|     Вход : P []                                                    |
|            P [p,k,q,i,omega,u]  - вектор параметров орбиты КА      |
|                                   в меридиональной                 |
|                                   (или экваториальной) с.к.        |
|            MJD         - модифицированная юлианская дата           |
|                          зпохи измерений                           |
|            tip         - управляющий параметр                      |
|            DEL_UT1     - поправка в значение UTC                   |
|            NPOST       - номер поста                               |
|                                                                    |
|     Выход: X []                                                    |
|            X,Y,Z       - координаты положения КА                   |
|                          в прямоугольной с.к.                      |
|            X_t,Y_t,Z_t - координаты вектора скорости КА            |
|                          в прямоугольной станционной с.к.          |
|                                                                    |
|     Статические переменные:                                        |
|            MKC[]           - массив коорд. постов                  |
|                              (DEL_X0, DEL_Y0, DEL_Z0,              |
|                               B_ct, L_ct, H_ct, KSI, ETA)          |
|     Используются константы :                                       |
|                 FM      = 398600.44              TKOC[3]           |
|                 OMEGAZ  = 0.729211585530659e-4   TKOC[2]           |
|                 a_KP    = 6378.245               TKOC[16]          |
|                 e2_KP   = 0.00669322             TKOC[54]          |
|                 EPS_X  (NPOST)                   TKOC[17]          |
|                 EPS_Y  (NPOST)                   TKOC[18]          |
|                 EPS_Z  (NPOST)                   TKOC[19]          |
|                 Xp_MUN - координаты мгновенного полюса  TKOC[61]   |
|                 Yp_MUN   относителбно МУН               TKOC[62]   |
|                                                                    |
|     Используются процедуры : MNUT     ZVEWI                        |
|                              YM_MV_6  YM_MV_3  YM_MM_3             |
|                                                                    |
|                                                    04.10.2006      |
|-------------------------------------------------------------------*/
int  POSTM (double p[6], double MJD, int tip, double DEL_UT1, int NPOST, double X[6])
{
	
	double rX, rY, rZ, tauX, tauY, tauZ;
    double R_, r, Vr, VT, Xz, Yz, Zz, Xtz, Ytz, Ztz, Xp_r, Yp_r;
	double Xka_ek[6], Xc[6], Xka_g[6], XT[6], A6[6]; 
    double Xcm[3], X1[3], DEL_X0_r[3], Xcm_g[3], A3[3];
	double A33[3][3], B33[3][3], C33[3][3], D33[3][3], E33[3][3], FR33[3][3];
	double Nt[3][3];

	double A66[6][6];
    double c_OM, c_u, c_i, s_OM, s_u, s_i;
	double s_s, c_s, s_B, c_B, s_L, c_L;
    double N_alfa, s, N;
	double B_ct_r, L_ct_r, H_ct_r, KSI_r, ETA_r;
	double s_KSI, c_KSI, s_ETA, c_ETA;
    double DEL_X0, DEL_Y0, DEL_Z0, B_ct, L_ct, H_ct, KSI, ETA, Xp_MUN, Yp_MUN;
    int j,l;

	Xp_MUN = TKOC[61];
    Yp_MUN = TKOC[62];

	DEL_X0 = MKC[(NPOST-1)*8];
	DEL_Y0 = MKC[(NPOST-1)*8 + 1];
	DEL_Z0 = MKC[(NPOST-1)*8 + 2];
	B_ct   = MKC[(NPOST-1)*8 + 3];
	L_ct   = MKC[(NPOST-1)*8 + 4];
	H_ct   = MKC[(NPOST-1)*8 + 5];
	KSI    = MKC[(NPOST-1)*8 + 6];
	ETA    = MKC[(NPOST-1)*8 + 7];

	s_i  = sin(p[3]);
	s_OM = sin(p[4]);
	s_u  = sin(p[5]);
	c_i  = cos(p[3]);
	c_OM = cos(p[4]);
	c_u  = cos(p[5]);
	rX   =  c_u * c_OM - s_u * s_OM * c_i;
    rY   =  c_u * s_OM + s_u * c_OM * c_i;
	rZ   =  s_u * s_i;
	tauX = -s_u * c_OM - c_u * s_OM * c_i;
	tauY = -s_u * s_OM + c_u * c_OM * c_i;
	tauZ =  c_u * s_i;
	R_   = 1. + p[2] * c_u + p[1] * s_u;
	r    = p[0] / R_;
	Vr   = sqrt(TKOC[3] / p[0]) * (p[2] * s_u - p[1] * c_u);
	VT   = sqrt(TKOC[3] / p[0]) * R_;
	Xz   = r * rX;
	Yz   = r * rY;
	Zz   = r * rZ;
	Xtz  = Vr * rX + VT * tauX;
	Ytz  = Vr * rY + VT * tauY;
	Ztz  = Vr * rZ + VT * tauZ;

    if (tip == 1) 
	{
	 Xc[0] = Yz;  Xc[1] = Zz;  Xc[2] = Xz;
	 Xc[3] = Ytz; Xc[4] = Ztz; Xc[5] = Xtz; 
	}
	else
	{ 
	 Xc[0] = Xz;  Xc[1] = Yz;  Xc[2] = Zz;
	 Xc[3] = Xtz; Xc[4] = Ytz; Xc[5] = Ztz; 
    }

    MNUT (MJD, Nt);
    for (l=0; l<6; l++)
    {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	}
    for (l=0; l<3; l++)
    {   
	    for (j=0; j<3; j++)
		{
		   A66[l][j] = Nt[l][j];
		   A66[l+3][j+3] = Nt[l][j];
		}	 
	}

    YM_MV_6 (A66, Xc, Xka_ek);
    N_alfa = Nt[1][0];
    ZVEWI(MJD, DEL_UT1, N_alfa, &s);

	s_s  = sin(s);
	c_s  = cos(s);
    for (l=0; l<6; l++)
    {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	}
    A66[0][0] =  c_s;  A66[0][1] = s_s;
    A66[1][0] = -s_s;  A66[1][1] = c_s;
    A66[2][2] =  1.0;
    A66[3][0] = -TKOC[2] * s_s;  A66[3][1] =  TKOC[2] * c_s;
	A66[3][3] =  c_s;           A66[3][4] =  s_s;
    A66[4][0] = -TKOC[2] * c_s;  A66[4][1] = -TKOC[2] * s_s;
	A66[4][3] = -s_s;           A66[4][4] =  c_s;
    A66[5][5] = 1.0;
    YM_MV_6 (A66, Xka_ek, Xka_g);

    B_ct_r   = B_ct * 0.1799;
    L_ct_r   = L_ct * 0.1828;

	/* ввести коэфф для H_ct */
	H_ct_r   = H_ct * 1.0;
    DEL_X0_r[0] = DEL_X0 * 0.1956;
	DEL_X0_r[1] = DEL_Y0 * 0.1952;
    DEL_X0_r[2] = DEL_Z0 * 0.1964;

    s_B = sin(B_ct_r);
    c_B = cos(B_ct_r);
    s_L = sin(L_ct_r);
    c_L = cos(L_ct_r);

	N = TKOC[16] / sqrt(1.0 - TKOC[54] *  s_B * s_B);
    Xcm[0] = (N + H_ct_r) * c_B * cos(L_ct_r);
    Xcm[1] = (N + H_ct_r) * c_B * sin(L_ct_r);
    Xcm[2] = (N + H_ct_r - N * TKOC[54]) * s_B;

	A33[0][0] =  1.0;	 A33[0][1] =  TKOC[19] ;  A33[0][2] = -TKOC[18]; 
	A33[1][0] = -TKOC[19];	 A33[1][1] =  1.0 ;	   A33[1][2] =  TKOC[17]; 
	A33[2][0] =  TKOC[18];	 A33[2][1] = -TKOC[17] ;  A33[2][2] =  1.0; 
    YM_MV_3 (A33, Xcm, A3);
	for (j=0; j<3; j++)  X1[j] = DEL_X0_r[j] + A3[j];

    Xp_r = Xp_MUN * TKOC[1] / 64800.;
	Yp_r = Yp_MUN * TKOC[1] / 64800.;
	A33[0][0] = 1.0;	 A33[0][1] =  0.0 ;  A33[0][2] = -Xp_r; 
	A33[1][0] = 0.0;	 A33[1][1] =  1.0 ;	 A33[1][2] =  Yp_r; 
	A33[2][0] = Xp_r;	 A33[2][1] = -Yp_r ; A33[2][2] =  1.0; 
    YM_MV_3 (A33, X1, Xcm_g);

    A6[0] = Xcm_g[0];  A6[1] = Xcm_g[1];  A6[2] = Xcm_g[2];
    A6[3] = 0.0;      A6[4] = 0.0;      A6[5] = 0.0;
	for (j=0; j<6; j++)  XT[j] = Xka_g[j] - A6[j];

	KSI_r    = KSI * 0.1925;
    ETA_r    = ETA * 0.1930;
    s_KSI = sin(KSI_r);
    c_KSI = cos(KSI_r);
    s_ETA = sin(ETA_r);
    c_ETA = cos(ETA_r);
	E33[0][0] =  c_KSI;	 E33[0][1] =  0.0;    E33[0][2] = s_KSI;
	E33[1][0] =  0.0;	 E33[1][1] =  1.0;	  E33[1][2] = 0.0;
	E33[2][0] = -s_KSI;	 E33[2][1] =  0.0;    E33[2][2] = c_KSI;
	B33[0][0] =  c_ETA;	 B33[0][1] =  s_ETA;  B33[0][2] = 0.0;
	B33[1][0] = -s_ETA;	 B33[1][1] =  c_ETA;  B33[1][2] = 0.0;
	B33[2][0] =  0.0;	 B33[2][1] =  0.0;    B33[2][2] = 1.0;
	C33[0][0] =  c_B;	 C33[0][1] =  0.0;    C33[0][2] = s_B;
	C33[1][0] =  0.0;	 C33[1][1] =  1.0;	  C33[1][2] = 0.0;
	C33[2][0] = -s_B;	 C33[2][1] =  0.0;    C33[2][2] = c_B;
	D33[0][0] =  c_L;	 D33[0][1] =  s_L;    D33[0][2] = 0.0;
	D33[1][0] = -s_L;	 D33[1][1] =  c_L;    D33[1][2] = 0.0;
	D33[2][0] =  0.0;	 D33[2][1] =  0.0;    D33[2][2] = 1.0;

    YM_MM_3 ( E33, B33, A33);
    YM_MM_3 ( A33, C33, FR33);
    YM_MM_3 ( FR33, D33, A33);

    for (l=0; l<6; l++)
    {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	}
    for (l=0; l<3; l++)
    {   
	    for (j=0; j<3; j++)
		{
		   A66[l][j] = A33[l][j];
		   A66[l+3][j+3] = A33[l][j];
		}	 
	}

    YM_MV_6 (A66, XT, X);

	return 0;
}
/************************************** end POSTM ****************************************/

/*----------------------------------------------------------
|                       OSKPAR                             |
|   Расчет оскулирующих параметров орбиты                  |
|                                                          |
|   Вход : p[6], tip                                       |
|   Выход: Структура   KU_OskPar(                          |  
|           e - эксцентриситет                             |  
|           а - большая полуось                            | 
|        Tosk - оскулирующий период                        | 
|           i - наклонение в экваториальной СК(ЭСК)        |     
|          om - инерциальная долгота ВУО в  ЭСК            |   
|           u - аргумент широты  в  ЭСК                    |
|         wpi - аргумент перигея в  ЭСК                    |
|         wpim- аргумент перигея в зависимтсти от          |
|               системы координат                          |
|         haр - высота апогея                              |
|         hpi - высота перигея     )                       |
|                                                          |
|   Используемые константы :                               |
|               PI         = 3.141592653589793    TKOC[1]  |
|               FM         = 398600.44            TKOC[3]  |
|               Rz         = Rz 6371.0            TKOC[8]  |
|                                                          |
|   Используемые процедуры :  UGOLM                        |
|                             PERUGM                       |
|                                         21.11.2005       |
----------------------------------------------------------*/
void OSKPAR(double p[6],int tip,KU_OskPar *op)
{
    double      e,a,tosk,a2,hap,hpi;
    double      bx[3],bx1[3],fi,sfi,cfi,wpi,wpim;
    
	    a2 = p[1]*p[1] + p[2]*p[2];
        e = sqrt(a2);
        a = p[0]/(1.0-a2);
	    tosk = TKOC[1]*2.0*(a*sqrt(a/TKOC[3]));
        hap = p[0]/(1.0 - e)-TKOC[8];
        hpi = p[0]/(1.0 + e)-TKOC[8];
		
		if (e>1.0e-08)
		{
		 sfi = (p[2]*sin(p[5]) - p[1]*cos(p[5]))/e; 
		 cfi = (p[2]*cos(p[5]) + p[1]*sin(p[5]))/e; 
		 UGOLM(sfi,cfi,&fi);
            wpi = p[5]-fi;
		 if(wpi<0.0) wpi=wpi+2.0*TKOC[1];
            wpim= wpi;
	        bx [0] = p[3];
  	        bx [1] = p[4];
		    bx [2] = p[5];
		 if(tip==1)
		 { 
		   PERUGM(bx,0,bx1);
		   bx[0]=bx1[0];
		   bx[1]=bx1[1];
		   bx[2]=bx1[2];
           wpi = bx[2]-fi;
		   if(wpi<0.0) wpi=wpi+2.0*TKOC[1];
		 }
		}
		else { wpi=0.0; wpim=0.0; }
 	op->e    = e;
	op->a    = a;
 	op->tosk = tosk;
	op->i    = bx[0];
	op->om   = bx[1];
	op->u    = bx[2];
	op->w    = wpi;
 	op->wm   = wpim;
 	op->hap  = hap;
	op->hpi  = hpi;
}
/************************************ end  OSKPAR ****************************************/

/*---------------------------------------------------------------
|                                 GEOCM                          |  
|               Определение геоцентрических координат КА         |  
|                                                                |  
|    Вход : t, p[6], tip,DEL_UT1;                                |  
|    где    t.d - сутки; t.s - секунды.                          |  
|                                                                |  
|    Выход: l-долгота,sh - широта                                |  
|                                                                |  
|    Используемые константы :                                    |  
|               PI     = 3.141592653589793    TKOC[1]            |
|   Используемые  процедуры :  SMJ2000                           |  
|                              MNUT                              |  
|                              ZVEWI                             |  
|                              YM_MV_3                           |  
|                              UGOLM                             |  
|                                       15.11.2005               | 
----------------------------------------------------------------*/
void GEOCM(KU_TimeDATA t,double p[6],int tip,double DEL_UT1,
		   double*l,double*sh)
{
	double mjd,N_alfa,sist,Nt[3][3];
	double cu,su,ci,si,com,som,cs,ss,a[3],b[3];
 
 
 /* Пересчет системного времени в модифицированную юлианскую дату */
     SMJ2000(&t,&mjd);
 /* Вычисление матрицы нутации */
     MNUT   (mjd, Nt);
     N_alfa = Nt[1][0];	 
 /* Вычисление угла,равного истинному звездному времени */
	 ZVEWI( mjd, DEL_UT1, N_alfa, &sist);
 /* Вычисление синуса и косинуса истинного звездного времени */
	 ss = sin(sist);      cs = cos(sist);
 /* Вычисление синусов и косинусов углов, определяющих плоскость орбиты */
	 si = sin(p[3]);   ci = cos(p[3]);
	som = sin(p[4]);  com = cos(p[4]);
	 su = sin(p[5]);   cu = cos(p[5]);
 /* Вычисление направляющих косинусов */
	 a[0] = cu*com-su*som*ci;
	 a[1] = cu*som+su*com*ci;
	 a[2] = su*si;
 /* Перестановка координат, КА на ГСО */
	 if (tip==1)	{ cu=a[0]; a[0]=a[1]; a[1]=a[2]; a[2]=cu; }
 /* Учет нутации */	
	YM_MV_3 (Nt, a, b);
 /* Вычисление геоцентрической широты*/	 
	 *sh=arcsn(b[2]);
 /* Вычисление геоцентрической долготы */	 
	 cu=sqrt(fabs(1.0-b[2]*b[2]));
	if (cu==0.0) *l=0.0;
    else
		{
		si=(b[1]*cs-b[0]*ss)/cu;
		ci=(b[0]*cs+b[1]*ss)/cu;
		UGOLM(si,ci,l);
		if (*l>TKOC[1]) *l = *l - 2.0*TKOC[1];
		}
}
/**************************************** end GEOCM ***************************************/

/*------------------------------------------------------------
|                       GEOD                                 |
|     Расчет   геодезических координат					     |
|                                                            |
|     Вход :												 |
|			 X,Y,Z - координаты положения КА в				 |
|						   геоцентрической СК				 |
|     Выход: B,L,H	 - координаты  КА в						 |
|						   геодезической СК					 |
|                                                            |
|     Используются константы :                               |
|                PI     = 3.14159265358979    TKOC[1]        |
|				 a		= 6378.136			  TKOC[100]		 |
|				 e2		=					  TKOC[101]		 |
|				 eps	= 0.001				  TKOC[102]		 |
|                                                            |
|                                            20.02.2002      |
|-----------------------------------------------------------*/
void GEOD(double X,double Y,double Z, double *B,double *L,double *H)
{
	double d,  B0, B1, H0, H1, N0, N1, tg_B1, tg_B0;
	double a, b, e2, eps;
	
    a  = TKOC[9];	    //6378.136; 
    e2 = TKOC[101];	    //6.6943661930997e-3;
    eps = TKOC[102];	//0.001; 
    b = a * sqrt(1.0-e2);

	if ((X==0.)&&(Y==0.)&&(Z==0.)) 
	{			
	  *B=0.0;	*L=0.; *H=-1.;
	  return;
	}

	d = sqrt(X*X+Y*Y);

	if (d==0.) 
	{
	  *H=Z*FSIGN(Z)-b;
	  *B=TKOC[1]/2.*FSIGN(Z);
	  *L=0.;
	  return;
	}
    else
	{
	  if (X==0.0) 
	  {
		if (Y>0.0) *L=TKOC[1]/2.;
		else
		if (Y<0.0)  *L=3.*TKOC[1]/2.;
	  }
	  else
	  {
	    *L=atan(Y/X);
		if (X<0.0)              *L=TKOC[1]+*L;
		else
		  if ((X>0.0)&&(Y<0.0)) *L=2.0*TKOC[1]+*L;
	  }
	}

	if (Z==0.)
	{
		*H=d-a;
		*B=0.;
	    return;
	}

	tg_B1=Z/d;
	B1=atan(tg_B1);
	N1=a/sqrt(1-e2*sin(B1)*sin(B1));
	H1=d/cos(B1)-N1;

	do
	{
		B0=B1; H0=H1; N0=N1; tg_B0=tg_B1;
		tg_B1=Z/d+N0*e2*tg_B0/(N0+H0);
		B1=atan(tg_B1);
		N1=a/sqrt(1-e2*sin(B1)*sin(B1));
		H1=d/cos(B1)-N1;
	}while (fabs(B1-B0)>eps);

	*H=H1;
	*B=B1;

return;
}
/********************************** end GEOD *********************************************/

/*----------------------------------------------------------
|                        DIRM                              |
| Пересчет из декартовой ск  в оскулирующие параметры      |
|   Вход : X[6]                                            |
|   Выход: R[6],RM[6]                                      |
|                                                          |
|   Используемые константы :                               |
|               PI         = 3.141592653589793    TKOC[1]  |
|                                                          |
|   Используемые процедуры : UGOLM                         | 
|                            PERUGM                        |
|                                                          |
|                                          15.10.01        |
----------------------------------------------------------*/
void DIRM(double X[6],double R[6],double Rm[6])
{
    double  x,y,z,xt,yt,zt,c1,c2,c3,c,in,om,u,
		    rp,rv,rt,su,cu,bx[3],bx1[3];
	double  som,com;


     x = X[0];  y  = X[1];  z  = X[2];
    xt = X[3];  yt = X[4];  zt = X[5];

	
	c1   = y*zt - z*yt;
	c2   = z*xt - x*zt;
	c3   = x*yt - y*xt;
	c = sqrt(c1*c1 + c2*c2 + c3*c3);
 
	rp = sqrt( x*x + y*y + z*z);
    rv = sqrt( xt*xt + yt*yt + zt*zt);
    rt = arcsn((x*xt + y*yt + z*zt)/(rp*rv));
   

	in   = TKOC[1]/2.0 - atan(c3/(sqrt(c1*c1 + c2*c2)));

    som   = c1/sqrt(c1*c1+c2*c2);	
    com   =-c2/sqrt(c1*c1+c2*c2);	
	UGOLM(som,com,&om);	

    su   =(z*c)/(rp*sqrt(c1*c1+c2*c2));	
    cu   =(c1*y - c2*x)/(rp*sqrt(c1*c1+c2*c2));	
    UGOLM(su,cu,&u);	

	R[0] = rp;
	R[1] = rv;
	R[2] = rt;
	R[3] = in;
	R[4] = om;
	R[5] = u;

	bx[0] = in;
	bx[1] = om;
	bx[2] = u;
	PERUGM(bx,1,bx1);
    Rm[0] = rp;
	Rm[1] = rv;
	Rm[2] = rt;
	Rm[3] = bx1[0];
	Rm[4] = bx1[1];
	Rm[5] = bx1[2];

}
/************************************* end DIRM *******************************************/
  
/*----------------------------------------------------------
|                        DECORM                            |
|  Пересчет параметров орбиты КА в декартовую систему      |
|  координат                                               |
|                                                          |
|   Вход : R(r,v,theta,i,om,u)                             |
|   Выход: X[6]                                            |
|                                                          |
|                                          22.11.2005      |
----------------------------------------------------------*/
void DECORM(double r[6],int tip, double X[6])
{
	double cu,com,ci,su,som,si,rx,ry,rz,tx,ty,tz,vr,vt;
	double e;

	su  = sin(r[5]);
	cu  = cos(r[5]);
	com = cos(r[4]);
	som = sin(r[4]);
	si  = sin(r[3]);
	ci  = cos(r[3]);
 
	vr=r[1]*sin(r[2]);
    vt=r[1]*cos(r[2]);

	rx=cu*com-su*som*ci;
	ry=cu*som+su*com*ci;
	rz=su*si;

	tx=-su*com-cu*som*ci;
	ty=-su*som+cu*com*ci;
	tz=cu*si;

	X[0]=r[0]*rx;
	X[1]=r[0]*ry;
	X[2]=r[0]*rz;
	X[3]=vr*rx + vt*tx;
	X[4]=vr*ry + vt*ty;
	X[5]=vr*rz + vt*tz;

    if(tip==1)
	{
		   e = X[0]; X[0] = X[1];
		X[1] = X[2]; X[2] = e;
		   e = X[3]; X[3] = X[4];
		X[4] = X[5]; X[5] = e;
	}
}
/************************************* end DECORM *****************************************/

/******************************************************/
/*                       PETJ                         */
/*        Пересчет вектора из текущей системы         */
/*        координат в систему координат J2000         */
/*                                                    */
/******************************************************/
void  PETJ( KU_TimeDATA *t,double p[6],int psk,int tip,
	          double xj[6],double pj[6])
{
	 int     i,j;
	 double  mjd,r[6],rjm[6],rj[6],x[6],mpr[3][3],tpr[6][6];

     if (psk==0) 
	 {
	   PIRM (p,r);
	   DECORM(r,tip,x);
	 }
     else for (i=0; i<6; i++) x[i] = p[i];

     SMJ2000(t,&mjd);
	 PREC2000(mjd, mpr);

     for (i=0; i<6; i++)
	 { for (j=0; j<6; j++) tpr[i][j] = 0.0; }

     for (i=0; i<3; i++)
	 {
		 for (j=0; j<3; j++) 
		 {
	      tpr[i  ][j  ] = mpr[j][i];
	      tpr[i+3][j+3] = mpr[j][i];
		 }	 
	 }
     YM_MV_6(tpr, x, xj);
     DIRM(xj,rj,rjm);  
     if   (tip==1) RIPM (rjm,pj);
     else          RIPM (rj ,pj);

}
/************************************ end PETJ ****************************************/

/*----------------------------------------------------------------------
|		                         PEJT                                   |
|	   Программа предназначена для пересчета вектора состояния КА,      |
|    заданного на стандартную эпоху J2000(2000.0, январь, 1.5)          |
|    в вектор на эпоху наблюдения                                       |
|                                                                       | 
|  	Вход:	pj(p,k,q,i,om,u),  если  признак psk	= 0                 |
|      или  pj(x,y,z,xt,yt,zt),если признак  psk	= 1                 |
|           tip  - переменная, определяющия систему координат           |
|  		    tip = 1, то система координат меридианальная (ГСО)          |
|  		    tip = 2, то система координат экваториальная (ВЭО)          |
|                                                                       |
| 	Выход: 	p(p,k,q,i,om,u) и  x(x,y,z,xt,yt,zt)                        |
|                                                                       |
|  Используются процедуры :PIRM   , RIPM,    DECORM, DIRM,              |
|	                         SMJ2000, PREC2000,YM_MV_6                  |
|                                                           03.03.08    |
------------------------------------------------------------------------*/
void  PEJT(KU_TimeDATA *t,double pj[6],int psk,int tip,
          double x[6],double p[6])
{
	 int     i,j;
	 double  mjd,r[6],rm[6],rj[6],xj[6],mpr[3][3],mp[6][6];

     if (psk==0) 
	 {
	   PIRM (pj,rj);
	   DECORM(rj,tip,xj);
	 }
     else for (i=0; i<6; i++) xj[i] = pj[i];

     for (i=0; i<6; i++)
	 { for (j=0; j<6; j++) mp[i][j] = 0.0; }

     SMJ2000(t,&mjd);
	 PREC2000(mjd, mpr);

     for (i=0; i<3; i++)
	 {
		 for (j=0; j<3; j++) 
		 {
	      mp[i  ][j  ] = mpr[i][j];
	      mp[i+3][j+3] = mpr[i][j];
		 }	 
	 }

     YM_MV_6(mp, xj, x);
     DIRM(x,r,rm);
	 
     if (tip==1) RIPM (rm,p);
     else        RIPM (r ,p);

}
/****************************** end  PEJT *************************************************/

/*--------------------------------------------------------
|                       SLOGM                            |
|          Алгоритм суммирования векторного времени      |
|   Алгоритм предназначен для суммирования (вычитания)   |
|   2-х векторных времен. На пользование алгоритмом      |
|   наложены следующие условия:                          |
|   - времена положительны                               |
|   - вычитаемое время не больше уменьшаемого            |
|                                                        |
|   Вход : t1,t2, k;                                     |
|          где t1.d -сутки, t1.s - секунды;              |
|              t2.d -сутки, t2.s - секунды;              |
|              k=1  - сложение  k=-1 - вычитание         |
|                                                        |
|   Выход: t3 -суммарное время                           |
|          где   t3.d -сутки, t3.s - секунды;            |
|                                                        |
|   Используются константы :  (TNOM =86400)              |
|                                          11.11.2004    |
|-------------------------------------------------------*/
int SLOGM (KU_TimeDATA *t1,KU_TimeDATA *t2, int k, KU_TimeDATA *t3)
{
	 int  c4;

	 t3->s = t1->s + k * t2->s;
	 c4 = (int)floor( t3->s / 86400 );
	 t3->d = t1->d + k * t2->d + c4;
	 t3->s = t3->s - c4 * 86400;

	 return 0;
}
/*********************************** end SLOGM *******************************************/

/*--------------------------------------------------------
|                       SCOVM                            |
|          Алгоритм сравнения времен                     |
|   Проверяется истинность выражения t1 > t2.            |
|   В этом случае выходному параметру а присваивается    |
|   значение 1, в противном случае  -1.                  |
|   Если t1 = t2, то а=0.                                |
|                                                        |
|   Вход : t1, t2;                                       |
|          где t1.d - сутки; t1.s - секунды.             |
|              t2.d - сутки; t2.s - секунды.             |
|   Выход: a;                                            |
|                                                        |
|                                          10.06.2005    |
|-------------------------------------------------------*/
int SCOVM (KU_TimeDATA *t1,KU_TimeDATA *t2, int *a )
{

	/* 10.06.2005 */
     *a =  0;
	 if ( t1->d > t2->d )
	 { 
		*a =  + 1;
        return 0;
	 }
     *a =  - 1;
	 if ( t1->d == t2->d )
	 { 
		if (t1->s > t2->s )
		{ 
			*a =  + 1;
            return 0;
		}
	 }
     *a =  - 1;

	 return 0;
}
/*********************************** end SCOVM *******************************************/

/*------------------------------------------------------------
|                       ZVEWS                                |
|        Расчет   среднего    звездного   времени            |
|            по модифицированной юлианской дате              |
|                                                            |
|     Вход : MJD, DEL_UT1;                                   |
|                                                            |
|            MJD     - модифицированная юлианская дата       |
|                      зпохи измерений                       |
|            DEL_UT1 - поправка в значение UTC               |
|                                                            |
|     Выход: s_m                                             |
|            s_m     - среднее звёздное время                |
|                                                            |
|     Используются константы :                               |
|                  DVAPI = 6.28318530717959     TKOC[11]     |
|                  MU_Z  = 1.002737909350795    TKOC[12]     |
|                                                            |
|                                            12.12.2006      |
|-----------------------------------------------------------*/
int ZVEWS(double MJD,  double DEL_UT1, double *s_m)
{
	 double  MJD_0, T0, sm0_r, sm_r, DEL;

  /*  Учет временной поправки     */	
    MJD = MJD + DEL_UT1 / 86400.0;
  /*  Вычисление MJD0 - значения модифицированной юлианской даты на  0h текущих суток */
	MJD_0 = floor(MJD);
  /*  Вычисление Т0 - количества столетий по 36525 суток от 0h 1 января 2000 г. до 0h текущих суток*/
    T0    = (MJD_0 - 51544.5) / 36525.0;
  /*  Вычисление среднего звездного времени на 0h текущих суток (в секундах);                      */
    sm0_r = 24110.54841 + 8640184.812866 * T0 + 0.093104 *T0 * T0;
  /*  Вычисление среднего звездного времени на 0h текущих суток (в радианах);                      */
	sm0_r = sm0_r * TKOC[11] / 86400.;
  /*  Вычисление в радианах части текущих суток (от 0h до текущей эпохи)                           */
    DEL = (MJD - MJD_0) * TKOC[12] * TKOC[11];
  /*  Вычисление среднего звездного времени на текущую эпоху                                       */
    sm_r = sm0_r + DEL;
  /*  Сброс оборотов (по 2PI)                                                                      */
	*s_m =  sm_r - TKOC[11] * floor(sm_r/TKOC[11]);

	return 0;
}
/************************************* end ZVEWS *****************************************/

/*------------------------------------------------------------
|                       ZVEWI                                |
|        Расчет   истинного    звездного   времени           |
|            по модифицированной юлианской дате              |
|                                                            |
|     Вход : MJD, DEL_UT1, N_alfa;                           |
|                                                            |
|            MJD     - модифицированная юлианская дата       |
|                      зпохи измерений                       |
|            DEL_UT1 - поправка в значение UTC               |
|            N_alfa  - нутация по прямому восхождению        |
|                      на зпоху измерений                    |
|                                                            |
|     Выход: s                                               |
|            s     - истинное звёздное время                 |
|                                                            |
|                                                            |
|     Используются константы :                               |
|                   DVAPI = 6.28318530717959     TKOC[11]    |
|                   MU_Z  = 1.002737909350795    TKOC[12]    |
|                                                            |
|                                            12.12.2006      |
|-----------------------------------------------------------*/
int ZVEWI(double MJD,  double DEL_UT1,  double N_alfa, double *s)
{
	 double  MJD_0, T0, sm0_r, s_r, DEL;

/*  Учет временной поправки                                                                      */	
    MJD = MJD + DEL_UT1 / 86400.;
/*  Вычисление MJD0 - значения модифицированной юлианской даты на  0h текущих суток              */
	MJD_0 = floor(MJD);

    T0    = (MJD_0 - 51544.5) / 36525.;
    sm0_r = 24110.54841 + 8640184.812866 * T0 + 0.093104 *T0 * T0;
	sm0_r = sm0_r * TKOC[11] / 86400.;
    DEL = (MJD - MJD_0) * TKOC[12] * TKOC[11];
    s_r = sm0_r + DEL + N_alfa;
	*s =  s_r - TKOC[11] * floor(s_r/TKOC[11]);

	return 0;
}
/************************************* end ZVEWI ******************************************/

/*------------------------------------------------------------
|                      KDS2000                               |
|                                                            |
|               Пересчёт календарной даты                    |
|         во время, прошедшее от 0-h 1 января 2000г.         |
|               (0-h московского времени)                    |
|   Вход:  D - календарная дата;                             |
|             D.y - год; D.m - месяц; D.d - число;           |
|             D.h - часы; D.min - минуты; D.sec - секунды    | 
|                                                            |
|   Выход: t - время                                         |
|             t.d - сутки; t.s - секунды                     |
|                                                            |
|                                         15.06.2004         |
------------------------------------------------------------*/
int KDS2000(KU_DateDATA *D, KU_TimeDATA *t)
{
	int k[13];
	int A1, A2, b_rab, sum, m, i ;
	double a_rab  ;

	 k[0] = 0;
	 k[1] = 31; k[2] = 28; k[3] = 31; k[4]  = 30; k[5]  = 31; k[6]  = 30;
     k[7] = 31; k[8] = 31; k[9] = 30; k[10] = 31; k[11] = 30; k[12] = 31;

    A1 = (D->y - 2000) * 365;
	a_rab = (D->y - 1) / 4.;
	A2 = (int)floor(a_rab) - 500;
	a_rab = D->y / 4.;    
    b_rab = (int)floor(a_rab) * 4;
	if (b_rab == D->y) k[2] = k[2] + 1;

	sum = 0;
	m = D->m;
	for (i=0; i<=m - 1; i=i+1) sum = sum + k[i];
		
	t->d = A1 + A2 + sum + D->d;
    t->s = D->h * 3600. + D->min * 60. + D->sec;

	return 0;
} 
/*********************************** KDS2000 *********************************************/

/*------------------------------------------------------------------
|                      SKD2000                                     |
|                                                                  |
|               Пересчёт системного времени,                       |
|     прошедшего от 0-h 1 января 2000г.,(0-h московского времени)  |
|                  в календарную дату                              |
|   Вход: t - время                                                |
|             t.d - сутки; t.s - секунды                           |
|   Выход:  D - календарная дата;                                  |
|             D.y - год; D.m - месяц; D.d - число;                 |
|             D.h - часы; D.min - минуты; D.sec - секунды          |
|																   |
|                                                    02.07.2004    |
------------------------------------------------------------------*/
int SKD2000 (KU_TimeDATA *t, KU_DateDATA *D )
{
	int k[12];
	int A1, d, G_n, j;
	double a_rab ;

	G_n = 2000; 
	 k[0] = 31; k[1] = 28; k[2] = 31; k[3] = 30; k[4]  = 31; k[5]  = 30;
     k[6] = 31; k[7] = 31; k[8] = 30; k[9] = 31; k[10] = 30; k[11] = 31;
     d = t->d;
  M3:
     A1 = (int)floor(G_n / 4.0) * 4;
	 if (A1 == G_n ) 
	 {
        	if (d >= 366) 
			{
                d = d - 366;
				G_n = G_n + 1;
				goto M3;
			}
            else k[1] = k[1] +1; 
	 }
     else
	 {
        	if (d >= 365) 
			{
                d = d - 365;
				G_n = G_n + 1;
				goto M3;
			}
            else goto M4; 
	 }	        
   M4:
	 j = 0;
   M5:
	 if (d >= k[j] )
	 {
	        d = d -  k[j];
			j = j + 1;
	        goto M5;
	 }
	 else
	 {
	        D->m     = j+1;
			D->d     = d+1;
			a_rab    = t->s / 3600;
			D->h     = (int)floor(a_rab);
            a_rab    = (t->s - D->h * 3600) / 60;
            D->min   = (int)floor(a_rab);
            D->sec   = t->s - D->h * 3600 - D->min * 60;
            D->y     = G_n;
	 }

	 return 0;
} 
/*********************************** end SKD2000 ****************************************/

/*------------------------------------------------------------
|                     MJS2000                                |
|                                                            |
|          Пересчёт модифицированной юлианской даты          |
|    в системное время,отсчитываемое от 0-h 1 января 2000г.  |
|                                                            |
|   Вход:  MJD     - модифицированная юлианская дата         |
|                    зпохи измерений                         |
|                                                            |
|   Выход: t       - системное время                         |
|                    t.d - сутки; t.s - секунды              |
|  Используются константы :                                  |
|                   MJD1_2000 = 51543.875   TKOC[14]         |
|                                                            |
|                                         05.07.2004         |
------------------------------------------------------------*/
int MJS2000(double MJD, KU_TimeDATA *t)
{
	double del_t  ;

	del_t = MJD - TKOC[14];
    t->d = (int)floor(del_t);
    t->s = (del_t - t->d) *86400;

	 return 0;
}
/********************************* end MJS2000 *******************************************/

/*------------------------------------------------------------
|                     SMJ2000                                |
|                                                            |
|          Пересчёт системного времени,отсчитываемого        |
|          от 0-h 1 января 2000г                             |
|          в модифицированную юлианскую даты                 |
|                                                            |
|   Вход:   t       - системное время                        |
|                     t.d - сутки; t.s - секунды             |
|   Выход:  MJD     - модифицированная юлианская дата        |
|                    зпохи измерений                         |
|                                                            |
|  Используются константы :                                  |
|                   MJD1_2000 = 51543.875    TKOC[14]        |
|                                                            |
|                                         21.10.2005         |
------------------------------------------------------------*/
int SMJ2000(KU_TimeDATA *t, double *MJD )
{
	 double dt  ;

     dt = t->d + t->s / 86400;
     *MJD = TKOC[14] + dt;

	 return 0;
}
/************************************ end SMJ2000 ****************************************/

/*------------------------------------------------------------
|                     KDMJ                                   |
|                                                            |
|               Пересчёт календарной даты                    |
|              московского зимнего времени                   |
|           в модифицированную юлианскую дату                |
|                                                            |
|   Вход:  D - календарная дата;                             |
|             D.y - год; D.m - месяц; D.d - число;           |
|             D.h - часы; D.min - минуты; D.sec - секунды    |                                                  |                                                            |
|                                                            |
|   Выход:  MJD     - модифицированная юлианская дата        |
|                    зпохи измерений                         |
|  Используются константы :                                  |
|                   MJD1_2000 = 51543.875    TKOC[14]        |
|                                                            |
|     Используются процедуры : KDS2000                       |
|                                                            |
|                                               09.04.2007   |
------------------------------------------------------------*/
void KDMJ(KU_DateDATA *D, double *MJD)
{
	 double del_t  ;
     KU_TimeDATA t;
  
  	 KDS2000( D,  &t);

     del_t = t.d + t.s / 86400.;

	 *MJD   =  TKOC[14] + del_t;
}
/************************************* end KDMJ *******************************************/
	
/**********************************************************/
/*                       INFOE                            */
/*   Расчет набора информационных параметров КА на ВЭО    */
/*                                                        */
/*   Вход : t, p[6], tip                                  */
/*   Выход: структура  KU_INFOE:                          */
/*           e - эксцентриситет                           */
/*           а - большая полуось                          */
/*        tosk - оскулирующий период                      */
/*        tdr - драконический период                      */
/*          ig - наклонение в экваториальной СК(ЭСК)(град)*/
/*         omg - инерциальная долгота ВУО в ЭСК  (град)   */
/*          ug - аргумент широты  в  ЭСК  (град)          */
/*         wpg - аргумент перигея в  ЭСК  (град)          */
/*         haр - высота апогея                            */
/*         hpi - высота перигея                           */
/*          lg - географическая долгота в  ЭСК  (град)    */
/*          fg - географическая широта  в  ЭСК  (град)    */
/*                                                        */
/*   Используемые константы : PI                          */ 
/*                                                        */
/*   Используемые процедуры :  OSKPAR()                   */
/*                             GEOCM()                    */
/*                             DRAKM()                    */
/*                                       22.11.05         */
/**********************************************************/
 int INFOE(KU_TimeDATA t,double p[6],int tip,double DEL_UT1,
	         KU_INFOE *opi)
{
    
    int i;
	double      l,sh,tdr,p0[6];
	double      PI;
    KU_OskPar   op;
    KU_TimeDATA t0;

    PI       =TKOC[ 1];
    OSKPAR(p,tip,&op);
	i=INTUUM(&t,&t0,0,0.0,p,p0,-tip);
    if (i<0) return i;
	GEOCM(t0,p0,tip,DEL_UT1,&l,&sh);
    i=DRAKM(t,p,tip,&tdr);
    if (i<0) return i;
    opi->e    = op.e;
    opi->a    = op.a; 
    opi->tosk = op.tosk;  
    opi->tdr  =    tdr;
    opi->ig   = op.i;
    opi->omg  = op.om;
	opi->ug   = op.u;
	opi->wpg  = op.w;
	opi->hap  = op.hap;
	opi->hpi  = op.hpi;
	opi->lg   = l *180.0/PI;
	opi->fg   = sh*180.0/PI;
   return 0;
  
}
/*********************************** end  INFOE ******************************************/

/*--------------------------------------------------------
|                       PEPAMK                            |
|   Пересчет орбитальных параметров КА в станционные      |
|                                                         |
|   Вход :  t, t_t, rh[6], tip;                           |
|    где :  t.d, t_t.d   - дни;                           |
|           t.s, t_t.s   - секунды;                       |
|           DEL_UT1      - поправка в значение UTC        |
|           NPOST        - номер поста                    |
|           ST_KOR       - структура массива коррекций    |
|                                                         |
|   Выход: dc[3];                                         |
|                                                         |
|   Используются процедуры :  RIPM                        |
|                             INTK                        |
|                             POSTM                       |
|                             STISF                       |
|                             SMJ2000                     |
|                                                         |
|                                          27.10.2006     |
|--------------------------------------------------------*/
int PEPAMK (KU_TimeDATA* t,KU_TimeDATA* t_t, double rh[6],
          int tip,  double DEL_UT1, int NPOST,  KU_MKOR *ST_KOR, double dc[3])
{
	 KU_TimeDATA t_stork;
	 double p[6],pl[6],al,bet,d1,dct;

    double MJD;
    double X[6];

	t_stork.d = t_t->d;
    t_stork.s = t_t->s;
    
	RIPM(rh,p);

    INTK(t, t_t, p, tip, ST_KOR, &kik, pl );

    SMJ2000( &t_stork, &MJD );

    POSTM ( pl, MJD, tip, DEL_UT1, NPOST, X);

    STISF ( X, &d1, &dct, &al, &bet);


    dc[0] = dct;
    dc[1] = al;
    dc[2] = bet;

	return 0;
} 
/************************************ end PEPAMK ******************************************/

/*--------------------------------------------------------------------------
|                                 PEGIN                                    |
|                      Пересчёт вектора параметров орбиты,                 |
|           заданного в прямоугольной с.к. ПЗ-90  Xpz[]                    |
|                     в   инерциальную  с.к. Xin[]                         |
|                                                                          |
|     Вход : Xpz [X,Y,Z,X_t,Y_t,Z_t]                                       |
|                         - координаты положения КА                        |
|                           в  с.к. ПЗ-90                                  |
|            MJD          - модифицированная юлианская дата                |
|                           зпохи измерений                                |
|            DEL_UT1      - поправка в значение UTC                        |
|                                                                          |
|     Выход: Xin [X,Y,Z,X_t,Y_t,Z_t]                                       |
|                         - координаты положения КА                        |
|                           в инерциальной  с.к.                           |
|                                                                          |
|     Используются процедуры : MNUT, ZVEWI,                                |
|                              YM_MV_6                                     |
|     Используются константы :                                             |
|                  PI     = 3.14159265358979          TKOC[1]              |
|                  OMEGAZ = 0.729211585530659e-4      TKOC[2]              |
|                  Xp_MUN - координаты мгновенного полюса  TKOC[61]        |
|                  Yp_MUN   относителбно МУН               TKOC[62]        |
|                                                                          |
|                                                         14.10.2005       |
|-------------------------------------------------------------------------*/
int  PEGIN (double Xpz[6], double MJD, double DEL_UT1,double Xin[6])
{
	 double Xek[6],Xg[6];
	 double P[3][3], P_T[3][3];
	 double Nt[3][3], Nt_T[3][3];
 	 double A66[6][6];
     int j, l;
	 double N_alfa, Xp_r, Yp_r, s, s_s, c_s, Xp_MUN, Yp_MUN;

	 Xp_MUN = TKOC[61];
	 Yp_MUN = TKOC[62];

     Xp_r = Xp_MUN * TKOC[1] / 64800;
	 Yp_r = Yp_MUN * TKOC[1] / 64800;
     P[0][0] = 1.0;
     P[1][1] = 1.0;
     P[2][2] = 1.0;
     P[0][1] = 0.0;
     P[1][0] = 0.0;
     P[0][2] =  Xp_r;
     P[2][0] = -Xp_r;
     P[1][2] = -Yp_r;
     P[2][1] =  Yp_r;

     for (l=0; l<3; l++)
	 {   
	      for (j=0; j<3; j++) P_T[l][j] = P[j][l];
	 }
     for (l=0; l<6; l++)
	 {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	 }
     for (l=0; l<3; l++)
	 {   
	      for (j=0; j<3; j++)
		  {
		   A66[l][j] = P_T[l][j];
		   A66[l+3][j+3] = P_T[l][j];
		  }	 
	 }

     YM_MV_6 (A66, Xpz, Xg);
     MNUT (MJD, Nt);
     N_alfa = Nt[1][0];
	 ZVEWI( MJD, DEL_UT1, N_alfa, &s);

     for (l=0; l<6; l++)
	 {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	 }
     A66[2][2] = 1.0;
	 A66[5][5] = 1.0;
	 s_s = sin(s);
	 c_s = cos(s);
     A66[0][0] =   c_s;	 A66[0][1] = - s_s;
     A66[1][0] =   s_s;	 A66[1][1] =   c_s;
     A66[3][0] = - TKOC[2] * s_s;	  A66[3][1] = - TKOC[2] * c_s;
	 A66[3][3] =   c_s;               A66[3][4] = - s_s;
     A66[4][0] =   TKOC[2] * c_s;	  A66[4][1] = - TKOC[2] * s_s;
	 A66[4][3] =   s_s;               A66[4][4] =   c_s;
     YM_MV_6 (A66, Xg, Xek);

     for (l=0; l<3; l++)
	 {   
	      for (j=0; j<3; j++) Nt_T[l][j] = Nt[j][l];
	 }	 

     for (l=0; l<6; l++)
	 {   for (j=0; j<6; j++)   A66[l][j] = 0.0;
	 }
     for (l=0; l<3; l++)
	 {   
	      for (j=0; j<3; j++)
		  {
		   A66[l][j] = Nt_T[l][j];
		   A66[l+3][j+3] = Nt_T[l][j];
		  }	 
	 }
     YM_MV_6 (A66, Xek, Xin);

	 return 0;
}
/*********************************** end PEGIN ********************************************/

/*---------------------------------------------------------------------
|                            POSJ                                     |
|         Пересчет оскулирующих параметров из текущей системы         |
|         координат в систему координат J2000                         |
|                                                                     |
|   Вход : t, (время привязки вектора)                                |
|          v,  (при v=0-вычисляется геоцентрическаядолгота ВУО назад, |
|               при v=1-вычисляется геоцентрическаядолгота ВУО вперед)|
|          DEL_UT1,  (поправка в значение UTC)                        |
|          KU_OSKP (структура, содержащая оскулирующие параметры      |
|          на текущую дату:                                           |
|           e - эксцентриситет                                        |
|        tosk - оскулирующий период                                   |
|           i - наклонение в экваториальной СК(ЭСК)                   |
|          om - инерциальная долгота ВУО в  ЭСК                       |
|           u - аргумент широты  в  ЭСК                               |
|         wpi - аргумент перигея в  ЭСК )                             |
|   Выход: KU_OSKP (структура, содержащая оскулирующие параметры      |
|          системы координат J2000:                                   |
|           e - эксцентриситет                                        |
|        tosk - оскулирующий период                                   |
|           i - наклонение в экваториальной СК(ЭСК)                   |
|          om - инерциальная долгота ВУО в  ЭСК                       |
|           u - аргумент широты  в  ЭСК                               |
|         wpi - аргумент перигея в  ЭСК)                              |
|         lvu - географическая долгота ВУО                            |
|                                                                     |
|   Используемые константы :                                          |
|               2PI        = 6.283185307179586   TKOC[11]             |
|               FM         = 398600.44           TKOC[ 3]             |
|                                                                     |
|   Используемые процедуры : PETJ,INTUUM,GEOCM,UGOLM                  |
|                                                    04.03.2008       |
---------------------------------------------------------------------*/
void POSJ(KU_TimeDATA t,int v,double DEL_UT1,KU_OSKP op,
          double *lvu,KU_OSKP *opj)
{
    int      tip,psk;
    double   a,b,p[6],pu[6],pj[6],xj[6],fi,sfi,cfi,sh;
    KU_TimeDATA tu;
       
       a    = exp(2.0/3.0*log(op.tosk/TKOC[11])+1.0/3.0*log(TKOC[3]));
	   p[0] = a*(1.0-op.e*op.e);
       p[1] = op.e*sin(op.wpi);
       p[2] = op.e*cos(op.wpi);
       p[3] = op.i;
	   p[4] = op.om;
	   p[5] = op.u;
       tip=2;
       INTUUM(&t, &tu,v,0.0,p,pu,tip);
	   GEOCM (tu,pu,tip,DEL_UT1,lvu,&sh);
       psk  = 0;
	   PETJ(&t,p, psk,tip,xj,pj);
	   b = pj[1]*pj[1]+pj[2]*pj[2];
       opj->e = sqrt(b);
       a = pj[0]/(1.0-b);
	   opj->tosk = TKOC[11]*(a*sqrt(a/TKOC[3]));

		if (opj->e>1.0e-08)
		{
		 sfi = (pj[2]*sin(pj[5]) - pj[1]*cos(pj[5]))/opj->e; 
		 cfi = (pj[2]*cos(pj[5]) + pj[1]*sin(pj[5]))/opj->e; 
		 UGOLM(sfi,cfi,&fi);
         opj->wpi = pj[5]-fi;
		 if(opj->wpi<0.0) opj->wpi=opj->wpi+TKOC[11];
		}
		else  opj->wpi=0.0; 
        opj->i = pj[3];
		opj->om= pj[4];
		opj->u = pj[5];
}
/********************************** end  POSJ *********************************************/

/*---------------------------------------------------------------------
|                            POSP                                     |
|      Пересчет оскулирующих параметров из системы координат J2000    |
|                 в текущую систему координат                         |
|                                                                     |
|   Вход : t, (время привязки вектора)                                |
|          v,  (при v=0-вычисляется геоцентрическаядолгота ВУО назад, |
|               при v=1-вычисляется геоцентрическаядолгота ВУО вперед)|
|          DEL_UT1,  (поправка в значение UTC)                        |
|          KU_OSKP (структура, содержащая оскулирующие параметры      |
|          системы координат J2000:                                   |
|           e - эксцентриситет                                        |
|        tosk - оскулирующий период                                   |
|           i - наклонение в экваториальной СК(ЭСК)                   |
|          om - инерциальная долгота ВУО в  ЭСК                       |
|           u - аргумент широты  в  ЭСК                               |
|         wpi - аргумент перигея в  ЭСК )                             |
|   Выход: KU_OSKP (структура, содержащая оскулирующие параметры      |
|          на текущую дату:                                           |
|           e - эксцентриситет                                        |
|        tosk - оскулирующий период                                   |
|           i - наклонение в экваториальной СК(ЭСК)                   |
|          om - инерциальная долгота ВУО в  ЭСК                       |
|           u - аргумент широты  в  ЭСК                               |
|         wpi - аргумент перигея в  ЭСК)                              |
|         lvu - географическая долгота ВУО                            |
|                                                                     |
|   Используемые константы :                                          |
|               2PI        = 6.283185307179586   TKOC[11]             |
|               FM         = 398600.44           TKOC[ 3]             |
|                                                                     |
|   Используемые процедуры : PEJT,INTUUM,GEOCM,UGOLM                  |
|                                                    04.03.2008       |
---------------------------------------------------------------------*/
void POSP(KU_TimeDATA t,int v,double DEL_UT1,KU_OSKP opj,
	      double *lvu,KU_OSKP *op)
{
    int      tip,psk;
    double   a,b,p[6],pu[6],pj[6],x[6],fi,sfi,cfi,sh;
    KU_TimeDATA tu;
       
       a    = exp(2.0/3.0*log(opj.tosk/TKOC[11])+1.0/3.0*log(TKOC[3]));
	   pj[0] = a*(1.0-opj.e*opj.e);
       pj[1] = opj.e*sin(opj.wpi);
       pj[2] = opj.e*cos(opj.wpi);
       pj[3] = opj.i;
	   pj[4] = opj.om;
	   pj[5] = opj.u;
       psk  = 0;
       tip=2;
	   PEJT(&t,pj, psk,tip,x,p);
       INTUUM(&t, &tu,v,0.0,p,pu,tip);
	   GEOCM (tu,pu,tip,DEL_UT1,lvu,&sh);
	   b = p[1]*p[1]+p[2]*p[2];
       op->e = sqrt(b);
       a = p[0]/(1.0-b);
	   op->tosk = TKOC[11]*(a*sqrt(a/TKOC[3]));

		if (op->e>1.0e-08)
		{
		 sfi = (p[2]*sin(p[5]) - p[1]*cos(p[5]))/op->e; 
		 cfi = (p[2]*cos(p[5]) + p[1]*sin(p[5]))/op->e; 
		 UGOLM(sfi,cfi,&fi);
         op->wpi = p[5]-fi;
		 if(op->wpi<0.0) op->wpi=op->wpi+TKOC[11];
		}
		else  op->wpi=0.0; 
        op->i = p[3];
		op->om= p[4];
		op->u = p[5];
}
/********************************* end  POSP **********************************************/




 