/***************************************************************************

                                XKY_HBO_4_0.c
                             -------------------
 
 ***************************************************************************/

#include "stdafx.h"

extern double MKC[];
extern double TKOC[];


/*--------------------------------------------------------
|                       UGOLM                            |
|         Нахождение угла в интеpвале   (0,2П)           |
|                                                        |
|   Вход : x,y                                           |
|                                                        |
|   Выход: al                                            |
|                                                        |
|   Используются константы :                             |
|               KP     = 1.0e-14             TKOC[20]    |
|               DVAPI  = 6.283185307179586   TKOC[11]    |
|                                                        |
|   Используются процедуры : fsign()                     |
|                                          10.11.2004    |
|-------------------------------------------------------*/
int UGOLM(double x,double y,double *al)	
{
	 double s,b,a;

     s = FSIGN(x);
	 b = fabs(x);
	 if (b>1.0)  *al = (TKOC[11]/4.0) * s;
	 else
	 {
		a = (1.0-b > TKOC[20]) ? asin(x) : (TKOC[11]/4.0)*s;
		if (y<0)   *al = TKOC[11]/2.0 - a;
		else  *al = (b >= TKOC[20])? a + TKOC[11]/2.0 - (TKOC[11]/2.0) * s : 0.0;
	 }
	 return 0;
}
/***************************** end UGOLM *************************************************/



/************************************** end KORIN_Ed ****************************************/

/*******************************************************/
/*                       Y2X                           */
/*     Решение системы двух линейных уравнений         */
/*                с двумя неизвестными                 */
/*                                                     */
/*   Вход:  а[2][2] - основная матрица системы         */
/*          b[2]    - столбец свободных членов         */
/*                                                     */
/*   Выход: х[2]    - столбец неизвестных              */
/*                                                     */
/*   Функция возвращает:                               */
/*          1, если система имеет единственное решение;*/
/*          0, если система не имеет решений или       */
/*             имеет бесконечное множество решений;    */
/*                                                     */ 
/*                                          23.01.08   */
/*******************************************************/      
int Y2X(double a[2][2], double b[2], double x[2])
{
	double det, det_x, det_y;

	det = a[0][0] * a[1][1] - a[1][0] * a[0][1];
	det_x = b[0] * a[1][1] - b[1] * a[0][1];
	det_y = a[0][0] * b[1] - a[1][0] * b[0];

	if (fabs (det) > TKOC[36]) 
	{
		x[0] = det_x / det;
		x[1] = det_y / det;

		return (1);
	}
	else  return (0);    
}
/************************************* end Y2X *******************************************/

/*******************************************************/
/*                       Y3X                           */
/*     Решение системы трех линейных уравнений         */
/*      с тремя неизвестными (матричный метод)         */
/*                                                     */
/*   Вход:  а[3][3] - основная матрица системы         */
/*          b[3]    - столбец свободных членов         */
/*                                                     */
/*   Выход: х[3]    - столбец неизвестных              */
/*                                                     */
/*   Функция возвращает:                               */
/*          1, если система имеет единственное решение;*/
/*          0, если система не имеет решений или       */
/*             имеет бесконечное множество решений;    */
/*                                                     */ 
/*                                          23.01.08   */
/*******************************************************/      
int Y3X(double a[3][3], double b[3], double x[3])
{
	double det;

	det = DET_3(a);

	if (fabs (det) > TKOC[36]) 
	{
        OMATR3(a);
		YM_MV_3(a,b,x);

		return (1);
	}
	else  return (0);	
}
/************************************* end Y3X *******************************************/

/*******************************************************/
/*                       Y5X                           */
/*     Решение системы пяти линейных уравнений         */
/*      с пятью неизвестными (матричный метод)         */
/*                                                     */
/*   Вход:  а[5][5] - основная матрица системы         */
/*          b[5]    - столбец свободных членов         */
/*                                                     */
/*   Выход: х[5]    - столбец неизвестных              */
/*                                                     */
/*   Функция возвращает:                               */
/*          1, если система имеет единственное решение;*/
/*          0, если система не имеет решений или       */
/*             имеет бесконечное множество решений;    */
/*                                                     */ 
/*                                          23.01.08   */
/*******************************************************/      
int Y5X(double a[5][5], double b[5], double x[5])
{
	double det;
	double c[5][5];             
	int i,j;

   for (i = 0; i < 5; i++)
   {
		for (j = 0; j < 5; j++)
		{
			c[i][j] = a[i][j];
		}
   }                            

	det = DET_5(a);

	if (fabs (det) > TKOC[36]) 
	{
        OMATR5(a);

		YM_MV_5(a,b,x);

		return (1);
	}
	else  return (0);		
}
/************************************* end Y5X *******************************************/

/*-------------------------------------------------------
|                        YM_MV_6                        |
|            Умножение матpицы 6х6 на вектоp            |
|                                                       |
|  Вход:  а[6][6], b[6]                                 |
|                                                       |
|  Выход: c[6]  (отличен от b[])                        |
|                                                       |
|                                          30.06.04     |
|------------------------------------------------------*/
int YM_MV_6 (double a[][6], double b[6], double c[6])
{
	 double r;
	 int i, j;

	 for (i = 1; i <= 6; i++)
	 {
		r = 0.0e00;
		for (j = 1; j <= 6; j++)
		{
			r = r + a[i-1][j-1] * b[j-1];
		}
		c[i-1] = r;
	 }
	 return 0;
}
/************************************ end YM_MV_6 ****************************************/

/*-------------------------------------------------------
|                        YM_MV_3                        |
|            Умножение матpицы 3х3 на вектоp            |
|                                                       |
|  Вход:  а[3][3], b[3]                                 |
|                                                       |
|  Выход: c[3]  (отличен от b[])                        |
|                                                       |
|                                          30.06.04     |
|------------------------------------------------------*/
int YM_MV_3 (double a[][3], double b[3], double c[3])
{
	 double r;
	 int i,j;

	 for ( i = 1; i <= 3; i++)
	 {
		r = 0.0e00;
		for (j = 1; j <= 3; j++)
		{
			r = r + a[i-1][j-1] * b[j-1];
		}
		c[i-1] = r;
	 }
 	 return 0;
}
/******************************** end YM_MV_3 ********************************************/

/*-------------------------------------------------------
|                        YM_MM_6                        |
|            умножение матpицы 6х6 на матpицу 6х6       |
|                                                       |
|  Вход:   a[6][6], b[6][6]                             |
|                                                       |
|  Выход:  c[6][6]  ( отличен от a[6][6] и b[6][6] )    |
|                                                       |
|                                          30.06.04     |
|------------------------------------------------------*/
int YM_MM_6 (double a[][6], double b[][6], double c[][6])
{
	 int i, j, l;

	 for (i = 1; i <= 6; i++)
	 {
		for (j = 1; j <= 6; j++)
		{
			c[i-1][j-1] = 0.0e00;
			for (l = 1; l <= 6; l++)
			{
				c[i-1][j-1] = c[i-1][j-1] + a[i-1][l-1] * b[l-1][j-1];
			}
		}
	 }
	 return 0;
}
/********************************* end YM_MM_6 *******************************************/

/*-------------------------------------------------------
|                        YM_MM_3                        |
|            умножение матpицы 3х3 на матpицу 3х3       |
|                                                       |
|  Вход:   a[3][3], b[3][3]                             |
|                                                       |
|  Выход:  c[3][3]  ( отличен от a[3][3] и b[3][3] )    |
|                                                       |
|                                          30.06.04     |
|------------------------------------------------------*/
int YM_MM_3 (double a[][3], double b[][3], double c[][3])
{
	 int i, j, l;

	 for (i = 1; i <= 3; i++)
	 {
		for (j = 1; j <= 3; j++)
		{
			c[i-1][j-1] = 0.0e00;
			for (l = 1; l <= 3; l++)
			{
				c[i-1][j-1] = c[i-1][j-1] + a[i-1][l-1] * b[l-1][j-1];
			}
		}
	 }
	 return 0;
}
/******************************* end YM_MM_3 *********************************************/

/*---------------------------------------------------------------
| 	                        OMATR                               |
| 	 Программа предназначена для вычисления матрицы,            |
| 	 обpатной матpице A.                                        |
|                                                               |
|   A - исходная матрица  типа double pазмеpности 6х6.          | 
|   Обpатная матpица будет помещена на  место исходной матрицы. |
|   eps_OMATR - точность вычисления элементов обратной матpицы. |
|   (задана константой в const_2005.h)                          |
|                                                               |
|   Если в процессе обращения матрицы какой-либо главный        |  
|   элемент окажется  меньше eps_OMATR, то выполнение программы |
|   прервется и возвpащаемое значение будет pавно 1.            |
|                                                               | 
|   Обращение   матрицы  производится  по  методу               |        
|   Гаусса-Жордана с выбором на каждом шаге в качестве          |   
|   главного элемента максимального элемента в еще              | 
|   непреобразованной части матрицы.                            |                       
|   Вспомагательная функция PERM_OMATR используется для         | 
|   пеpестановки элементов матpицы.                             |
|                                                               |
|   Используются константы :                                    |
|               eps_OMATR     = 1.0e-12    TKOC[36]             |
|                                                               |                                 
|   Вход : A[6][6]       -  матрица  рамерности 6*6             |
|                                                               |
|   Выход: A[6][6]       -  матрица  рамерности 6*6             |
|                                                               |
|   Используются процедуры :  PERM_OMATR                        |
|                             fabs                              |
|                                                 04.10.2005    |
|--------------------------------------------------------------*/
int OMATR( double  a[6][6])
{
	 double pv ;
	 int i, j, ii, k, pi, pj, ri, ci, rk, r[6], c[6], js;

	 for (i = 1; i <= 6; i++)
     {
		r [i-1] = i;
		c [i-1] = i;
	 }
	 pi = 1;
	 pj = 1;
	 for (i = 1; i <= 6; i++)
	 {
		for (j = 1; j <= 6; j++)
		{
			if ( fabs ( a [i-1][j-1] ) > fabs ( a [pi-1][pj-1] ))
			{
				pi = i;
				pj = j;
			}
		}
	 }
	 for ( i = 1; i <= 6; i++)
	 {
		ri = r [pi -1];
		r [pi -1] = r [i -1];
		r [i-1] = ri;
		ci = c [pj-1];
		c [pj-1] = c [i-1];
		c [i-1] = ci;
		if (TKOC[36] > fabs ( a [ri -1][ci - 1] ))
		{
			for (ii = 1; ii <= 6; ii++)
			{
				for ( j = 1; j <= 6; j++)
				{
					a [ii -1][j-1] = (double) 0.0;
				//	printf ("   ГЛАВНЫЙ ЭЛЕМЕНТ МЕНЬШЕ EPS \n ");
					return 1;
				}
			}
		}
		for ( j =1; j <= 6; j++)
		{
			if ( j != i)
			{
				js = c [j-1];
				a [ri-1][js-1] = a [ri-1][js-1] / a [ri-1][ci-1];
			}
		}
		a [ri-1][ci-1] = (double)1.0 / a [ri-1][ci-1];
		pv = (double) 0.0;
		for ( k =1; k <= 6; k++)
		{
			if (k != i)
			{
				rk = r [k-1];
				for  ( j = 1; j <= 6; j++)
				{
					if ( j != i)
					{
						js = c [j-1];
						a [rk-1][js-1] = a [rk-1][js-1] -
										a [ri-1][js-1] * a [rk-1][ci-1];
						if (k > i)
						{
							if (j > i)
							{
								if (fabs ( a [rk-1][js-1]) >= fabs (pv-1))//;
								{
									pi = k;
									pj = j;
									js = c [j-1];
									pv = a [rk-1][js-1];
								}
							}
						}
					}
				}
				a [rk-1][ci-1] = - a [ri-1][ci-1] * a [rk-1][ci-1];
			}
		}
	 } // end for ( i = 1; i <= 6; i++) 

	  PERM_OMATR (a, r, c, 1);
	  PERM_OMATR (a, c, r, 2);

	return 0;
}
/*********************************** end OMATR *******************************************/

/*--------------------------------------------------------
|                        FSIGN                           |
|              Нахождение знака числа                    |
|                                                        |
|                                          15.10.01      |
|--------------------------------------------------------*/
int FSIGN(double x)
{
      if(x>0.)	                      return(1);
	  if(x<0.)                        return(-1);
	  else
	                                  return(0);
}
/******************************* end FSIGN ***********************************************/

/*----------------------------------------------------------
| функция одного  аpгумента,  аналог  функции  ARCCOS.     |
| Отличается от ARCCOS pасшиpенной областью опpеделения.   |
-----------------------------------------------------------*/
double arccs(double x /* значение косинуса угла */)
{
	if((x > -1.0) && (x < 1.0)) return (acos(x));
    else if(x >= 1.0)  return(0.0);
         else   return(TKOC[1]);
}
/******************************************************************************************/

/*----------------------------------------------------------
| функция одного  аpгумента,  аналог  функции  ARCSIN.     |
| Отличается от ARCSIN pасшиpенной областью опpеделения.   |
-----------------------------------------------------------*/
double arcsn(double x /* значение синуса угла */ )
{
 if((x > -1.0) && (x < 1.0))  return(asin(x));
 else if(x >= 1.0)  return(TKOC[1]/2.0);
      else   return(-TKOC[1]/2.0);
}
/******************************************************************************************/

/****************************************************/
/*	                  YM_MV_5                       */
/*	        Умножение матpицы 5х5 на вектоp 5x1     */
/*	                                                */
/*	  Вход:  а[5][5], b[5]                          */
/*	                                                */
/*	  Выход: c[5]                                   */
/*	                                                */
/*	                                     04.12.07   */
/****************************************************/
int YM_MV_5 (double a[5][5], double b[5], double c[5])
{
	int i, j;

	for (i = 0; i < 5; i++)
	 {
		c[i] = 0.0;

		for (j = 0; j < 5; j++)
		{
			c[i] = c[i] + a[i][j] * b[j];
		}
	 }

	 return 0;
} 
/********************************* end YM_MV_5 ***********************************/

/*****************************************************/
/*                       DET_3                       */
/*     Вычисление определителя третьего порядка      */
/*                                                   */
/*    Вход: а[3][3]                                  */
/*                                                   */
/*    Функция возвращает значение определителя       */
/*                                                   */
/*                                        14.12.07   */
/*****************************************************/  
double DET_3(double a[3][3])
{
	double det;

	det =  a[0][0] * (a[1][1] * a[2][2] - a[1][2] * a[2][1]) -
		   a[0][1] * (a[1][0] * a[2][2] - a[2][0] * a[1][2]) + 
		   a[0][2] * (a[1][0] * a[2][1] - a[1][1] * a[2][0]);
		  
	return(det);
}
/************************************ end DET_3 *****************************************/

/*****************************************************/
/*                       DET_4                       */
/*     Вычисление определителя четвертого порядка    */
/*                                                   */
/*    Определитель матрицы равен сумме произведений  */ 
/*    элементов нулевой строки матрицы а[4][4] на    */
/*    их алгебраические дополнения                   */
/*                                                   */ 
/*    Вход: а[4][4] - матрица четвертого порядка     */
/*                                                   */
/*    Функция возвращает значение определителя       */
/*                                                   */
/*    Используются процедуры :  DET_3                */
/*                                                   */
/*                                        14.12.07   */
/*****************************************************/  
double DET_4(double a[4][4])
{
	double det;
	double b[3][3],d[4];
	int ii, jj, j;

	det = 0.0;

	for(j = 0; j < 4; j++)                 // цикл по элементам нулевой строки
	{
	   for(ii = 1; ii < 4; ii++)
			for(jj = 0; jj < 4; jj++)
			{
				if(jj < j) b[ii - 1][jj] = a[ii][jj];
				if(jj > j) b[ii - 1][jj - 1] = a[ii][jj];
			}

       d[j] = DET_3(b);
	   det = det + pow(-1.0,j + 2) * a[0][j] * d[j];
	}

	return(det);
}
/************************************ end DET_4 *****************************************/

/*****************************************************/
/*                       DET_5                       */
/*     Вычисление определителя пятого порядка        */
/*                                                   */
/*    Определитель матрицы равен сумме произведений  */ 
/*    элементов нулевой строки матрицы а[5][5] на    */
/*    их алгебраические дополнения                   */
/*                                                   */
/*    Вход: а[5][5] - матрица пятого порядка         */
/*                                                   */
/*    Функция возвращает значение определителя       */
/*                                                   */
/*    Используются процедуры :  DET_4                */
/*                                                   */
/*                                        20.12.07   */
/*****************************************************/  
double DET_5(double a[5][5])
{
 	double det;
	double b[4][4],d[5];
	int ii, jj, j;

	det = 0.0;

	for(j = 0; j < 5; j++)                 // цикл по элементам нулевой строки
	{
	   for(ii = 1; ii < 5; ii++)
			for(jj = 0; jj < 5; jj++)
			{
				if(jj < j) b[ii - 1][jj] = a[ii][jj];
				if(jj > j) b[ii - 1][jj - 1] = a[ii][jj];
			}

       d[j] = DET_4(b);                        
	   det = det + pow(-1.0,j + 2) * a[0][j] * d[j];
	}

	return(det);
}
/*************************************** end DET_5 ***************************************/

/*********************************************************/
/*                       MINOR_2                         */
/*     Программа вычисления минора второго порядка       */
/*                                                       */
/*  По заданным номерам строки и столбца элемента данной */
/*  матрицы программа вычисляет соответствующий минор    */
/*  второго порядка                                      */
/*                                                       */
/*  Вход:  i, j - индексы элемента, для которого         */
/*                вычисляется минор                      */
/*         a[3][3] - матрица пятого порядка              */
/*                                                       */ 
/*  Функция возвращает значение вычисленного минора      */
/*                                                       */
/*  Используются процедуры :  DET_2                      */
/*                                         23.01.08      */
/*********************************************************/     
double MINOR_2(int i, int j, double a[3][3])
{
   int ii, jj;
   double M[2][2];
   double det;

   for(ii = 0; ii < 3; ii++)
   {
	   if(ii != i)
		   for(jj = 0; jj < 3; jj++)
		   {
			   if(ii < i && jj < j) M[ii][jj] = a[ii][jj];
               if(ii < i && jj > j) M[ii][jj - 1] = a[ii][jj];
			   if(ii > i && jj < j) M[ii - 1][jj] = a[ii][jj];
			   if(ii > i && jj > j) M[ii - 1][jj - 1] = a[ii][jj];
		   }
   }

   det = M[0][0] * M[1][1] - M[0][1] * M[1][0];
   return(det);
}
/********************************** end MINOR_2 *****************************************/

/*********************************************************/
/*                       MINOR_4                         */
/*     Программа вычисления минора четвертого порядка    */
/*                                                       */
/*  По заданным номерам строки и столбца элемента данной */
/*  матрицы программа вычисляет соответствующий минор    */
/*  четвертого порядка                                   */
/*                                                       */
/*  Вход:  i, j - индексы элемента, для которого         */
/*                вычисляется минор                      */
/*         a[5][5] - матрица пятого порядка              */
/*                                                       */ 
/*  Функция возвращает значение вычисленного минора      */
/*                                                       */
/*  Используются процедуры :  DET_4                      */
/*                                         09.01.08      */
/*********************************************************/     
double MINOR_4(int i, int j, double a[5][5])
{
   int ii, jj;
   double M[4][4];
   double det;

   for(ii = 0; ii < 5; ii++)
   {
	   if(ii != i)
		   for(jj = 0; jj < 5; jj++)
		   {
			   if(ii < i && jj < j) M[ii][jj] = a[ii][jj];
               if(ii < i && jj > j) M[ii][jj - 1] = a[ii][jj];
			   if(ii > i && jj < j) M[ii - 1][jj] = a[ii][jj];
			   if(ii > i && jj > j) M[ii - 1][jj - 1] = a[ii][jj];
		   }
   }

   det = DET_4(M);

   return(det);
}
/********************************** end MINOR_4 *****************************************/

/**********************************************************/
/*                        OMATR3                          */
/* Программа вычисления обpатной матpицы третьего порядка */
/*                                                        */
/* 	Обращение матрицы производится c помощью вычисления   */        
/*  алгебраических дополнений элементов данной матрицы    */    
/*                                                        */
/*  Вход : a[3][3]       -  матрица  рамерности 3*3       */
/*                                                        */
/*  Выход: a[3][3]       -  матрица  рамерности 3*3       */
/*                                                        */
/*  Используются процедуры :  DET_3, MINOR_2              */
/*                                                        */
/*                                            23.01.08    */       
/**********************************************************/         
int OMATR3( double  a[3][3])
{
  double AD[3][3];
  double det,M;
  int i,j;

  det = DET_3(a);

  if (TKOC[36] > fabs (det))  printf ("   Матрица необратима \n ");   

  for(i = 0; i < 3; i++)
  {
	  for(j = 0; j < 3; j++)
	  {
         M = MINOR_2(i,j,a);
		 AD[j][i] = pow(-1.0, i+j+2) * M; 
	  }
  }

  for(i = 0; i < 3; i++)
  {
	  for(j = 0; j < 3; j++) a[i][j] = AD[i][j] / det;
	  
  }

  return(1);
}
/*********************************** end OMATR3 *******************************************/

/**********************************************************/
/*                        OMATR5                          */
/*  Программа вычисления обpатной матpицы пятого порядка  */
/*                                                        */
/* 	Обращение матрицы производится c помощью вычисления   */        
/*  алгебраических дополнений элементов данной матрицы    */    
/*                                                        */
/*  Вход : a[5][5]       -  матрица  рамерности 5*5       */
/*                                                        */
/*  Выход: a[5][5]       -  матрица  рамерности 5*5       */
/*                                                        */
/*  Используются процедуры :  DET_5, MINOR_4              */
/*                                                        */
/*                                            09.01.08    */       
/**********************************************************/         
int OMATR5( double  a[5][5])
{
  double AD[5][5];
  double det,M;
  int i,j;

  det = DET_5(a);

  if (TKOC[36] > fabs (det))  printf ("   Матрица необратима \n ");    

  for(i = 0; i < 5; i++)
  {
	  for(j = 0; j < 5; j++)
	  {
         M = MINOR_4(i,j,a);
		 AD[i][j] = pow(-1.0, i+j+2) * M;
	  }
  }

  for(i = 0; i < 5; i++)
  {
	  for(j = 0; j < 5; j++) a[i][j] = AD[j][i] / det;
  }

  return(1);
}
/*********************************** end OMATR5 *******************************************/

/*----------------------------------------------------------------
|                             PERM_OMATR                         |
|	    Вспомогательная процедура для OMATR                      |
|      для пеpестановки элементов матpицы    рамерности 6*6.     |
|	                                                             |
|	Вход	s[6]	- массив индексов строк                      |		
|	        d[6]	- массив индексов столбцов                   |
|		    priz	- признак обращения (1 - первое обращение,   | 
|								         2 - второе обращение)   |
|	       	A[6][6]			- матрица  размерности 6*6           |
|                                                                |
|	Выход	A[6][6]			- матрица  размерности 6*6           | 
|	                                                             |
|                                                 04.10.2005     |
----------------------------------------------------------------*/
int  PERM_OMATR( double a[6][6], int s[6], int d[6], int priz)
{
 double w;
 int  i, p, ta [6], l [6], t, j, k, js;

 for ( i = 1; i <= 6; i++)
 {
	ta [i-1] = i;
	l [i-1] = i;
 }
 for ( i =1; i <= 6; i++)
 {
	t = s [i-1];
	j = l [t-1];
	k = d [i-1];
	if ( j != k)
	{
		if ( priz == 2 )
		{
			for ( p = 1; p <= 6; p++)
			{
  				w = a [p-1][j-1];
				a [p-1][j-1] = a [p-1][k-1];
				a [p-1][k-1] = w;
			}
		}
		else
		{
			for ( p = 1; p <= 6; p++)
			{
				w = a [j-1][p-1];
				a [j-1][p-1] = a [k-1][p-1];
				a [k-1][p-1] = w;
			}
		}
		ta [j-1] = ta [k-1];
		ta [k-1] = t;
		js = ta [j-1];
		l [t-1] = l [js-1];
		l [js-1] = j;
	}  // end if ( j != k) 
 }//	end for ( i =1; i <= 6; i++) 
return 0;
}
/********************************* end PERM_OMATR *****************************************/


/***************************************************************************/
/* Транспонирование матрицы                                                */
/***************************************************************************/
void TRANSMA(double a[3][3],
             double at[3][3])
{
	int i,j;

	 for (i=0;i<3;i++)
		for (j=0;j<3;j++)  
			at[i][j]=a[j][i];
}
/***************************************************************************/
/* Скалярное произведение двух векторов                                    */
/***************************************************************************/
double SKALPR(double x[3],double y[3])
{ 
	return(x[0]*y[0] + x[1]*y[1] + x[2]*y[2]);
}
/***************************************************************************/
/* Линейная   комбинация  двух векторов                                    */
/***************************************************************************/
void LKOMB(double a,double va[3],double b,double vb[3],
           double c[3])
{ 
	int i;
  
	for (i=0;i<3;i++)  c[i] = a * va[i] + b * vb[i];
}
/****************************************************************************/
/* Векторное умножение                                                      */
/****************************************************************************/
void VEKTUMN(double v1[3],double v2[3],
             double v3[3])
{
 v3[0] = v1[1] * v2[2] - v1[2] * v2[1];
 v3[1] = v1[2] * v2[0] - v1[0] * v2[2];
 v3[2] = v1[0] * v2[1] - v1[1] * v2[0];
}
/****************************************************************************/
/* Заполнение матрицы значениями                                            */
/****************************************************************************/
void ZAPOLN(double m[3][3],double m00,double m01,double m02,
                           double m10,double m11,double m12,
                           double m20,double m21,double m22 )
{
	m[0][0]=m00;m[0][1]=m01;m[0][2]=m02;
	m[1][0]=m10;m[1][1]=m11;m[1][2]=m12;
	m[2][0]=m20;m[2][1]=m21;m[2][2]=m22;
}
/***************************************************************************/
/* Ноpмиpование вектоpа                                                    */
/***************************************************************************/
int NORMV(double x[3])      /*параметр возврата:1-вектор нормируется
						0-слишком маленький  */
{ 
	double m,eps11;
	int pv=1;

	//eps1= TKOC[18];
	eps11= 0.00000000001;

	m=MODUL(x);
	if (m > eps11)
	{
	     x[0]=x[0]/m; x[1]=x[1]/m; x[2]=x[2]/m;
	}
	else
	{
		pv=0;
		x[0]=0.0;x[1]=0;x[2]=0;
	}
	return (pv);
}
/******************************************************************/
/** Копирование вектора********************************************/
/******************************************************************/
void AvB(double a[],double b[])
{
	int i;

	for (i=0;i<3;i++) b[i]=a[i];
}
/***************************************************************************/
/* норма вектора                                                           */
/***************************************************************************/
double MODUL(double xv[3])
{
	return(sqrt(xv[0]*xv[0] + xv[1]*xv[1] + xv[2]*xv[2]));
}           
/***************************************************************************/
