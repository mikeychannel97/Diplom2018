/***************************************************************************

                                XKY_HBO_4_6.c
                             -------------------
 
 ***************************************************************************/

#include "stdafx.h"
extern double MKC[];
extern double TKOC[];


/*------------------------------------------------------------
|                       FAARM                                |
|     Расчет   фундаментальных астрономических аргументов    |
|            ( фундаментальные аргументы отнесены            |
|              к среднему равноденствию даты (J2000) )       |
|                                                            |
|     Вход : MJD                                             |
|            MJD     - модифицированная юлианская дата       |
|                      зпохи измерений                       |
|                                                            |
|     Выход: L_b, L, L_1, F_b, D_b                           |
|            L_b     - средняя долгота Луны на дату          |
|            L       - средняя аномалия Луны                 |
|            L_1     - средняя аномалия Солнца               |
|            F_b     - аргумент широты Луны                  |
|            D_b     - средняя элонгация Луны от Солнцф      |
|                                                            |
|     Используются константы :                               |
|                PI     = 3.14159265358979    TKOC[1]        |
|                R_FAAR = 1296000             TKOC[15]       |
|                                                            |
|                                            10.04.2007      |
|-----------------------------------------------------------*/
void FAARM (double MJD, double *L_b, double *L, double *L_1, double *F_b, double *D_b)
{
	 double T, L_b_rab, L_rab, L_1_rab, F_b_rab, D_b_rab;

     T = (MJD - 51544.5) / 36525.;
     L_b_rab = 785939.157 + (1336 * TKOC[15] + 1108372.598) * T - 5.802 * T * T;
     L_b_rab = L_b_rab * TKOC[1] / 648000.;
     *L_b = L_b_rab  - TKOC[11] * floor(L_b_rab / TKOC[11]);
     L_rab = 485866.733 + (1325 * TKOC[15] + 715922.633) * T + 31.310 * T * T;
     L_rab = L_rab * TKOC[1] / 648000.;
     *L = L_rab  - TKOC[11] * floor(L_rab / TKOC[11]);
     L_1_rab = 1287099.804 + (99 * TKOC[15] + 1292581.224) * T - 0.577 * T * T;
     L_1_rab = L_1_rab * TKOC[1] / 648000.;
     *L_1 = L_1_rab  - TKOC[11] * floor(L_1_rab / TKOC[11]);
     F_b_rab = 335778.877 + (1342 * TKOC[15] + 295263.137) * T - 13.257 * T * T;
     F_b_rab = F_b_rab * TKOC[1] / 648000.;
     *F_b = F_b_rab  - TKOC[11] * floor(F_b_rab / TKOC[11]);
     D_b_rab = 1072261.307 + (1236 * TKOC[15] + 1105601.328) * T - 6.891 * T * T;
     D_b_rab = D_b_rab * TKOC[1] / 648000.;
     *D_b = D_b_rab  - TKOC[11] * floor(D_b_rab / TKOC[11]);
		
}
/******************************** end FAARM ************************************************/

/*------------------------------------------------------------
|                       MNUT                                 |
|     Расчет   матрицы нутации								 |
|                                                            |
|                                                            |
|                                                            |
|     Вход : MJD                                             |
|            MJD        - модифицированная юлианская дата    |
|                                                            |
|     Выход: Nut[3][3]                                       |
|            Nut[3][3]  - матрица нутации                    |
|                                                            |
|     Используются процедуры : FAARM                         |
|                                                            |
|                                            17.06.2004      |
|-----------------------------------------------------------*/
void MNUT (double MJD, double Nut[3][3])
{
	double T ;
    double k1, k2, k3, k4, k5, k6, k7, k8, k9, k10;
    double k11, k12, k13, k14, k15, k16, k17, k18, k19, k20;
    double k21, k22;
    double A1, A2, A3, A4, A5;
	double DELpsi_s,  DELeps_s, eps_0;

    k1  = 8.33860138961157e-005;
	k2  = 9.99685810447863e-007;
	k3  = 6.39323801279145e-006;
	k4  = 6.91344309262198e-007;
	k5  = 1.05204568800769e-007;
	k6  = 2.50648673133630e-007;
	k7  = 6.25409648631301e-008;
	k8  = 1.10246631084308e-006;
	k9  = 3.45187340949990e-007;
	k10 = 1.87138080908281e-007;
	k11 = 1.45928918013970e-007;
	k12 = 5.96320827764729e-008;
	k13 = 7.66005616153067e-008;
	k14 = 4.46149790041050e-005;
	k15 = 4.33908244593035e-007;
	k16 = 2.78089127484430e-006;
	k17 = 1.08598264568536e-007;
	k18 = 4.73662966444017e-007;
	k19 = 9.69627362219072e-008;
	k20 = 6.25409648631301e-008;
    k21 = 0.409092804222329;
	k22 = 0.000226965524811;
  
    T = (MJD - 51544.5) / 36525.;

    FAARM ( MJD, &A1, &A2, &A3, &A4, &A5);
    DELpsi_s = - k1 * sin(A1 - A4) + k2 * sin(2*A1 - 2*A4) - k3 * sin(2*A1 - 2*A5)
		       + k4 * sin(A3) + k5 * sin(2*A1 - 2*A5 - A3) - k6 * sin(2*A1 - 2*A5 + A3)
               + k7 * sin(A1 - 2*A5 + A4) - k8 * sin(2*A1) + k9 * sin(A2)
			   - k10 * sin(A1 + A4) - k11 * sin(2*A1 + A2) + k12 * sin(2*A1 - A2)
			   - k13 * sin(A2 - 2*A5);
    DELeps_s =   k14 * cos(A1 - A4) - k15 * cos(2*A1 - 2*A4) + k16 * cos(2*A1 - 2*A5)
		       + k17 * cos(2*A1 - 2*A5 + A3) + k18 * cos(2*A1) + k19 * cos(A1 + A4)
               + k20 * cos(2*A1 + A2);
	eps_0    =   k21 - k22 * T;
    
	Nut[0][0] = 1.;
	Nut[0][1] = - DELpsi_s * cos(eps_0);
  	Nut[0][2] = - DELpsi_s * sin(eps_0);
	Nut[1][0] =   DELpsi_s * cos(eps_0);
	Nut[1][1] = 1.;
  	Nut[1][2] = - DELeps_s;
  	Nut[2][0] =   DELpsi_s * sin(eps_0);
  	Nut[2][1] =   DELeps_s;
	Nut[2][2] = 1.;

}
/*********************************** end MNUT *********************************************/

/*----------------------------------------------------------------
|                          PREC2000                              |
|    Расчет  матрицы прцессии по модифицированной юлианской дате |
|       ( относительно среднего равноденствия даты (J2000) )     |
|                                                                |
|         Вход : MJD                                             |
|                MJD        - модифицированная юлианская дата    |
|                                                                |
|         Выход: Prec[3][3]                                      |
|                Prec[3][3]  - матрица прецессии                 |
|                                                                |
|     Используются константы :                                   |
|                     PI    = 3.14159265358979  TKOC[1]          |
|                     DVAPI = 6.28318530717959  TKOC[11]         |
|                                                                |
|                                            10.04.2007          |
|---------------------------------------------------------------*/
void PREC2000 (double MJD, double Prec[3][3])
{
	double T ;
    double ksi_A, z_A, teta_A;
	double s_ksi_A, c_ksi_A, s_z_A, c_z_A, s_teta_A, c_teta_A;

    T = (MJD - 51544.5) / 36525;
    ksi_A    = 2306.2181 * T + 0.30188 * T * T;
    ksi_A    = ksi_A * TKOC[1] / 648000;
    ksi_A    = ksi_A - TKOC[11] * floor(ksi_A / TKOC[11]);
    z_A      = 2306.2181 * T + 1.09468 * T * T;
    z_A      = z_A * TKOC[1] / 648000;
    z_A      = z_A - TKOC[11] * floor(z_A / TKOC[11]);
    teta_A   = 2004.3109 * T - 0.42655 * T * T;
    teta_A   = teta_A * TKOC[1] / 648000;
    teta_A   = teta_A - TKOC[11] * floor(teta_A / TKOC[11]);

    s_ksi_A  = sin(ksi_A);
    c_ksi_A  = cos(ksi_A);
    s_z_A    = sin(z_A);
    c_z_A    = cos(z_A);
    s_teta_A = sin(teta_A);
    c_teta_A = cos(teta_A);

    Prec[0][0] = -s_ksi_A * s_z_A + c_ksi_A * c_z_A * c_teta_A;
    Prec[0][1] = -c_ksi_A * s_z_A - s_ksi_A * c_z_A * c_teta_A;
    Prec[0][2] = -c_z_A * s_teta_A;
    Prec[1][0] =  s_ksi_A * c_z_A + c_ksi_A * s_z_A * c_teta_A;
    Prec[1][1] =  c_ksi_A * c_z_A - s_ksi_A * s_z_A * c_teta_A;
    Prec[1][2] = -s_z_A * s_teta_A;
    Prec[2][0] =  c_ksi_A * s_teta_A;
    Prec[2][1] = -s_ksi_A * s_teta_A;
    Prec[2][2] =  c_teta_A;
	
}
/********************************** end PREC2000 ******************************************/

/****************************************************************/
/*                     VEKDAT_E                                 */
/*	Определение вектора состояния КА в апогее на заданную дату  */
/*              с учётом протяжённых коррекций                  */
/*                                                              */
/*                                                              */
/*                                                  22.03.2007  */
/****************************************************************/
int VEKDAT_E( //INPUT
			KU_TimeDATA *t0, // время привязки опорного вектора
			double  P0[6],	 // вектор состояния 
			KU_DateDATA *D,  // дата 
			int		tip,	 // тип орбиты 
			int		Pv,		 // признак второго (восточного) витка 
			                 // Pv = 1 - первый виток, Pv = 2 - второй виток    
            KU_MKOR *MK,     // структура  массива коррекций 
			  //OUTPUT
			KU_TimeDATA	*ta, // время привязки опорного вектора в апогее, сутки 
			double  Pa[6]	 //вектор состояния в апогее 
		  )
{
	int  j, ap;
	double t,tta;
	KU_TimeDATA td;

	KDS2000(D, &td);

	t = TIME_t(td);
	j=0;
	
	ap = 1;

	do{

	APSIDK(t0, P0, tip, j, ap, MK, ta, Pa);
	tta = TIME_t(*ta);

	j += 2;

	}while(tta < t);

	if(Pv == 2) APSIDK(ta, Pa, tip, 1, ap, MK, ta, Pa);

	return 0;
}
/****************************** end VEKDAT_E *********************************/ 

/*****************************************************************/
/*                     VEKDAT_RU                                 */
/* Определение вектора состояния КА в начале РУ на заданную дату */
/*              с учётом протяжённых коррекций                   */
/*                                                               */
/*                                                     9.07.2009 */
/*****************************************************************/
int VEKDAT_RU( //INPUT
			 KU_TimeDATA *t0, // время привязки опорного вектора
			 double  P0[6],	  // вектор состояния 
			 KU_DateDATA *D,  // дата 
			 double taB,      // 
			 int		tip,  // тип орбиты 
			 int		Pv,	  // признак второго (восточного) витка 
			                  // Pv = 1 - первый виток, Pv = 2 - второй виток    
             KU_MKOR *MK,     // структура  массива коррекций 
			  //OUTPUT
			 KU_TimeDATA *tru,// время привязки опорного вектора в начале РУ, сутки 
			 double  Pru[6]   // вектор состояния в начале РУ 
		     )
{
	int  i, j, ap, kik;
	double t, tta;
	double Pa[6], Pa1[6];
	KU_TimeDATA td, ta, ta1;

	KDS2000(D, &td);

	t = TIME_t(td);
	j=0;
	
	ap = 1;

	do{

	APSIDK(t0, P0, tip, j, ap, MK, &ta, Pa);
	tta = TIME_t(ta);
 
	if(tta >= t - 86400)                           
	{
		ta1 = ta;
		for(i = 0; i <= 5; i++) Pa1[i] = Pa[i];
	}

	j += 2;

	}while(tta < t);

	if(Pv == 2) APSIDK(&ta, Pa, tip, 1, ap, MK, &ta, Pa);  

	tta = TIME_t(ta);
	*tru = t_TIME(tta - taB); 

	INTK(&ta1, tru, Pa1, tip, MK, &kik, Pru);

	return 0;
}
/****************************** end VEKDAT_RU *********************************/ 

/*---------------------------------------------------------------------
|		                         SOLM                                  |
|	   Программа предназначена для вычисления прямоугольных            |
|     координат SOLM в экваториальной системе координат                |
|     ось Х которой направлена в среднюю точку весеннего               |
|     равноденствия (на момент времени, для которого                   |
|     вычисляются коордтинаты), ось Z направлена по оси                |
|     Мира, а ось Y дополняет систему до правой                        |
|	   psk = 1 - координаты SOLM  в средней экваториальной системе     |
|	   psk = 2 - координаты SOLM  в средней экваториальной системе     |
|				 на эпоху J2000.                                       |
|                                                                      |
|	Вход		:	MJD		- модифицированная юлианская дата в UTC    |
|					psk		- признак выходных координат:              |
|	Выход		:	xl[4]  -  вектор координат Луны                    |
|                                                                      |
|       Используются константы :                                       |
|      AU  = 1.49597870691e+8  астрономическая единица длины   TKOC[21]|
|      RS  = 4.848136811095e-6 число радиан в угловой секунде  TKOC[22]|      
|	   DTT_DTA = 65.184	значения поправки с 1.1.2006           TKOC[60]|
|                                                                      |  
|	                FAARM                                              |
|	                PREC2000                                           |
|					YM_MV_3	                                           |
|---------------------------------------------------------------------*/
void  SOLM(double mjd,  int psk, double xs[4])
{
     double  ec, E, r, l, wc, xlp[3], mjdp, DTT_DTA,
	        t, vc, xse, yse, se, ce, eps, mpr[3][3], tpr[3][3];

	 DTT_DTA = TKOC[60];

    /* Переход от юлианской даты, соответствующей всемирному координированному времени UTC,
	   к юлианской дате, соответствующей земному времени TT */
	 mjdp = mjd + DTT_DTA/86400.0;
	/* Вычисление времени в юлианских столетиях от эпохи J2000 */
 	 t = (mjdp - 51544.5)/36525.0;

    /* Вычисление среднего наклона эклиптики к экватору, */
    /* а также синуса и косинуса этого угла              */
     eps = (84381.448-46.815*t)*TKOC[22];
     se = sin(eps);
     ce = cos(eps);

    /* Вычисление эксцентриситета орбиты Земли */  
	 ec = 0.0167086342 - 0.00004203654*t- 1.2673e-07*t*t;
    /* Вычисление средней долготы солнечного перигея */  
     wc  = (1018578.046 + 6190.046*t+1.666*t*t)*TKOC[22];
    /* Вычисление средней аномалии солнца */  
	 E = (1287099.804 + 129596581.224*t-0.577*t*t)*TKOC[22];
	/*  истинная аномалия Солнца; */
	 vc = E + 2.0*ec*sin(E) + 1.25*ec*ec*sin(2.0*E);
	/*  истинная долгота Солнца;*/
	 l = wc + vc;

	/*  расстояние до Солнца;*/
	 r = (1.0 - ec * ec )/(1.0 + ec*cos(vc)); /** au*/
	/*     эклиптические декартовы координаты Солнца; */
	 xse = cos(l);
	 yse = sin(l);
	/*    Вычисление направляющих косинусов и расстояния */
	 xs[0] = xse;
	 xs[1] = yse * ce;
	 xs[2] = yse * se;
	 xs[3] =   r * TKOC[21];

	 if(psk==2) 
	 {
		PREC2000(mjd, mpr);
        tpr[0][0]=mpr[0][0]; tpr[0][1]=mpr[1][0]; tpr[0][2]=mpr[2][0];
        tpr[1][0]=mpr[0][1]; tpr[1][1]=mpr[1][1]; tpr[1][2]=mpr[2][1];
        tpr[2][0]=mpr[0][2]; tpr[2][1]=mpr[1][2]; tpr[2][2]=mpr[2][2];
        YM_MV_3(tpr, xs, xlp);
        xs[0]=xlp[0];
		xs[1]=xlp[1];
		xs[2]=xlp[2];
	 }
}
/*********************************** end  SOLM ********************************************/

/*-----------------------------------------------------------------------
|		                         LUNM                                   |
|	   Программа предназначена для вычисления прямоугольных             |
|     координат Луны в экваториальной системе координат                 |
|     ось Х которой направлена в среднюю точку весеннего                |
|     равноденствия (на момент времени, для которого                    |
|     вычисляются коордтинаты), ось Z направлена по оси                 |
|     Мира, а ось Y дополняет систему до правой                         |
|	   psk = 1 - координаты Луны  в средней экваториальной системе      |
|	   psk = 2 - координаты Луны  в средней экваториальной системе      |
|				 на эпоху J2000.                                        |  
|                                                                       |  
|	Вход		:	MJD		- модифицированная юлианская дата в UTC     |
|					psk		- признак выходных координат:               |           
|	Выход		:	xl[4]  -  вектор координат Луны                     |             
|                                                                       |              
|       Используются константы :                                        |
|      RS  = 4.848136811095e-6 число радиан в угловой секунде  TKOC[22] |
|	   DTT_DTA = 65.184	значения поправки с 1.1.2006           TKOC[60] |
|                                                                       |
|	                FAARM                                               |
|	                PREC2000                                            |         
|					YM_MV_3	                                            |
------------------------------------------------------------------------*/
void LUNM(double mjd,int psk, double xl[4])
{
    double se,ce,eps,al,alm,alm2,e,f,d,
    	   mpr[3][3],rl,xe,ye,ze, DTT_DTA;
    double d2,all,bl,pl,sl,cl,sb,cb,
           mjdp,tmjd,xlp[3],tpr[3][3];

    DTT_DTA = TKOC[60];

    /* Переход от юлианской даты, соответствующей  UTC,
      к юлианской дате, соответствующей земному времени TT */
      mjdp = mjd + DTT_DTA/86400.0;
    /* Вычисление времени в юлианских столетиях от эпохи J2000 */
      tmjd =(mjdp-51544.5)/36525.0;

    /* Вычисление среднего наклона эклиптики к экватору ep0*/
    /* а также синуса и косинуса этого угла                */
      eps = (84381.448-46.815*tmjd)*TKOC[22];
      se=sin(eps);
      ce=cos(eps);
      FAARM (mjdp,&al,&alm,&e,&f,&d);

      d2  = 2.0*d;
      alm2= 2.0*alm;
   // Вычисление синуса и косинуса эклиптической долготы Луны
      all =(22639.500*sin(alm)
		   -4586.465*sin(alm-d2)
		   +2369.912*sin(d2)
		    +769.016*sin(alm2)
		    -668.146*sin(e)
		    -411.608*sin(2.0*f)
		    -211.656*sin(alm2-d2)
	 	    -205.962*sin(alm+e-d2)
		    +191.953*sin(alm+d2)
	 	    -165.145*sin(e-d2)
		    +147.687*sin(alm-e)
		    -125.154*sin(d)
		    -109.673*sin(alm+e)
            -55.173*sin(2.0*f -d2)
            -45.099*sin(alm +2.0*f)
            +39.528*sin(alm -2.0*f)
            -38.428*sin(alm -2.0*d2)
            +36.124*sin(3.0*alm)
            -30.773*sin(alm2-2.0*d2))*TKOC[22];
      all=al+all;
      sl = sin(all);
      cl = cos(all);
   // Вычисление синуса и косинуса эклиптической широты Луны;
	  bl  =(18461.480*sin(f)
		   +1010.180*sin(f+alm)
		    -999.695*sin(f-alm)
		    -623.658*sin(f-d2)
		    +199.485*sin(f+d2-alm)
		    -166.577*sin(f-d2+alm)
		    +117.262*sin(f+d2)
		     +61.913*sin(alm2+f)
		     -33.359*sin(f-alm-d2)
		     -31.763*sin(f-alm2))*TKOC[22];
      sb = sin(bl);
	  cb = cos(bl);

   //  вычисление синуса параллакса и расстояния Луны
      pl  =  3422.7
		        +186.5398*cos(alm)
			 +34.3117*cos(alm-d2)
			 +28.2333*cos(d2)
			 +10.1657*cos(alm2)
			  +3.0861*cos(alm+d2)
			  +1.9178*cos(e-d2)
			  +1.4437*cos(alm+e-d2)
			  +1.1528*cos(alm-e)
			  -0.9781*cos(d)
			  -0.9490*cos(alm+e)
			  -0.7136*cos(alm-2.0*f);

      rl=1315.646695e+06/pl;

   //  вычислим декартовы координаты в эклиптической системе
		xe=cl*cb;
		ye=sl*cb;
		ze=sb;
   //  перейдем в экваториальную систему эпохи даты
     xl[0] = xe;
     xl[1] = ce*ye - se*ze;
     xl[2] = se*ye + ce*ze;
     xl[3] = rl;

   //  перейдем в экваториальную систему эпохи J2000 
	 if(psk==2) 
	 {
		PREC2000(mjdp, mpr);
        tpr[0][0]=mpr[0][0]; tpr[0][1]=mpr[1][0]; tpr[0][2]=mpr[2][0];
        tpr[1][0]=mpr[0][1]; tpr[1][1]=mpr[1][1]; tpr[1][2]=mpr[2][1];
        tpr[2][0]=mpr[0][2]; tpr[2][1]=mpr[1][2]; tpr[2][2]=mpr[2][2];
        YM_MV_3 (tpr, xl, xlp);
        xl[0]=xlp[0];
	    xl[1]=xlp[1];
	    xl[2]=xlp[2];
	 }
}
/*********************************** end LUNM *********************************************/

/*********************************************************/
/*                      TIME_t                           */
/*    Функция перевода системного векторного времени     */
/*    во время в секундах                                */
/*********************************************************/
double TIME_t(KU_TimeDATA tc)
{
	double t;

	t=tc.d*86400.+tc.s;
	return t;
}
/************************************** end TIME_t ************************************/

/*********************************************************/
/*                      t_TIME                           */
/*    Функция перевода времени в секундах в системное    */
/*    векторное время                                    */
/*********************************************************/
KU_TimeDATA t_TIME(double t)
{
	KU_TimeDATA tc;
	double dn,h;

	h=t/86400.;
	tc.s=86400.* modf(h,&dn);
	tc.d=(int)dn;
	return tc;
}
/************************************ end t_TIME **************************************/


/************************************************************/
/*                     Fprc                                 */
/*															*/
/*           Программа формирования файла                   */
/*	     регистрации процесса расчёта комплексного          */
/*                     алгоритма                            */
/*                                             20.04.2007   */
/************************************************************/
void Fprc(char str[15], char str1[15])
{
	int err;
    FILE *fp;
	
/* 1 */
	if ((err = fopen_s(&fp, str1, "at")) == NULL)
	{
		fprintf(stderr, "1 Cannot open input file %s\n", str1);
		exit(0);		
	}
	else
	{
        printf("1 open input file %s\n", str1);
	}

/* 2 */
    fprintf(fp,"          ");
	fprintf(fp,"%s\n",str);

/* 3 */
    fclose(fp);
}

/************************************* end Fprc *************************************/

/************************************************************/
/*                      FprcEnd                             */
/*															*/
/*           Программа формирования завершающего            */
/*                 сообщения в файле                        */
/*	     регистрации процесса расчёта комплексного          */
/*                     алгоритма                            */
/*                                              20.04.2007  */
/************************************************************/
void FprcEnd(char str[15], char str1[15])
{
	int err;
    FILE *fp;
	
/* 1 */
	if ((err = fopen_s(&fp, str1, "at")) == NULL)
	{
		fprintf(stderr, "1 Cannot open input file %s\n", str1);
		exit(0);		
	}
	else
	{
    //    printf("1 open input file %s\n", str1);
	}

/* 2 */
	fprintf(fp,"\n      %s",str);
	fprintf(fp,"    Calculation is completed.\n\n\n ");

/* 3 */
    fclose(fp);
}

/************************************ end FprcEnd *************************************/

/************************************************************/
/*                      FprcCancel                          */
/*															*/
/*           Программа формирования завершающего            */
/*       сообщения о невозможности расчета в файле          */
/*	     регистрации процесса расчёта комплексного          */
/*                     алгоритма                            */
/*                                              10.09.2009  */
/************************************************************/
void FprcCancel(char str[15], char str1[15])
{
	int err;
    FILE *fp;
	
/* 1 */
	if ((err = fopen_s(&fp, str1, "at")) == NULL)
	{
		fprintf(stderr, "1 Cannot open input file %s\n", str1);
		exit(0);		
	}
	else
	{
    //    printf("1 open input file %s\n", str1);
	}

/* 2 */
	fprintf(fp,"\n      %s",str);
	fprintf(fp,"    Calculation is impossible.\n\n\n ");

/* 3 */
    fclose(fp);
}

/************************************ end FprcCancel **********************************/

/**************************************************************************************/
KU_TimeDATA get_ibm_sys_times70(KU_DateDATA *D)
{

	KU_TimeDATA t;
	time_t times;
	
	int ai, j, i, s[12], ft, dn;

/* 1 */
// определение текущего календарного времени в секундах 		
	time(&times);

/* 2 */
	times = times + 3 * 3600;

/* 3 */
// перевод текущего календарного времени из секунд в сутки, секунды 
	t = t_TIME((double)times);

/* 4 */	
	D->m = 1;
	D->d = 1;
	D->y = 1970;
	ft = t.d;

/* 5 */
	for (i=1; i<=12;i++)  s [i-1]=31;
	for (i=4; i<=6;i=i+2)
		 {
		 s[i-1] = 30;
		 s[i+4] = 30;
		 }
	s[1] = 28;

/* 6 */
	dn = 365;
	if ( D->y == D->y / 4 * 4) dn = dn + 1;
	while ( ft >= dn)
		{
		ft = ft - dn;
		D->y = D->y + 1;
		dn = 365;
		if ( D->y == D->y / 4 * 4) dn = dn + 1;
		}

/* 7 */
	s[1] = s[1] + dn - 365;
	j = 1;
	while (ft >= s[j-1])
		{
		ft = ft - s [j-1];
		j = j + 1;
		}
	D->m = j;

/* 8 */
	D->d = ft + D->d;

/* 9 */
	D->h = (int) t.s / 3600;

/* 10 */
	ai = (int)(t.s - (double)D->h * 3600);
	D->min = ai / 60;

/* 11 */
	D->sec = (t.s - (double)D->h * 3600) - (double)D->min * 60;

	return t;

}
/*****************************************************************************************/





